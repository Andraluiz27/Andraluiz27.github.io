<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goetia</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Times New Roman', serif; background-color: #1a1a1a; color: #d1d1d1; }
        .card-button { border: 1px solid #4a4a4a; background-color: #2a2a2a; color: #c0c0c0; padding: 8px 12px; margin: 4px; border-radius: 6px; cursor: pointer; text-align: left; transition: all 0.2s ease-in-out; box-shadow: 0 2px 4px rgba(0,0,0,0.5); font-size: 0.9rem; }
        .card-button:hover:not(:disabled) { background-color: #3a3a3a; border-color: #888; }
        .card-button:disabled { cursor: not-allowed; opacity: 0.5; }
        .sacrificing { border-color: #ef4444 !important; box-shadow: 0 0 8px #ef4444; }
        .game-board-element { border: 2px solid #5a3a1a; background-color: #3a2a1a; }
        .prophecy-list li { font-size: 0.9rem; margin-bottom: 4px; cursor: help; position: relative; }
        .prophecy-list li .tooltip { visibility: hidden; width: 250px; background-color: #333; color: #fff; text-align: center; border-radius: 6px; padding: 5px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -125px; opacity: 0; transition: opacity 0.3s; }
        .prophecy-list li:hover .tooltip { visibility: visible; opacity: 1; }
        .prophecy-completed { text-decoration: line-through; color: #4ade80; }
        .turn-indicator { transition: all 0.3s ease; }
        .opponent-card { background-color: #1e1e1e; border: 1px dashed #4a4a4a; color: #666; }
        #game-id-display { user-select: all; }
        /* Estilos para o novo modal de profecia */
        .prophecy-choice-label { display: block; padding: 12px; border: 1px solid #4a4a4a; border-radius: 6px; background-color: #2a2a2a; cursor: pointer; transition: background-color 0.2s; }
        .prophecy-choice-label:hover { background-color: #3a3a3a; }
        input[type="radio"]:checked + .prophecy-choice-label { background-color: #4c1d95; border-color: #8b5cf6; }
        input[type="radio"] { opacity: 0; position: fixed; width: 0; }
        .domain-card-item { background-color: #2a2a2a; color: #c0c0c0; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; border: 1px solid #4a4a4a; }
        
        /* Novos estilos para Log e Chat */
        .log-area, .chat-area { background-color: #1f1f1f; border: 1px solid #4a4a4a; height: 180px; overflow-y: auto; padding: 10px; font-family: monospace; font-size: 0.85rem; }
        .log-area { display: flex; flex-direction: column-reverse; }
        .log-area strong { color: #f59e0b; }
        .chat-area { display: flex; flex-direction: column; }
        .chat-message { padding: 6px 10px; border-radius: 12px; margin-bottom: 6px; max-width: 85%; word-wrap: break-word; }
        .chat-message.player1 { background-color: #1e40af; color: #eff6ff; align-self: flex-start; border-bottom-left-radius: 2px; }
        .chat-message.player2 { background-color: #15803d; color: #f0fdf4; align-self: flex-end; border-bottom-right-radius: 2px; }
        .chat-message .sender { font-weight: bold; font-size: 0.75rem; display: block; margin-bottom: 2px; opacity: 0.9; }

        /* Estilos para seleção de modo de jogo */
        .game-mode-selector { display: flex; justify-content: center; gap: 1rem; margin-bottom: 1.5rem; }
        .mode-btn { padding: 10px 20px; border: 2px solid #4a4a4a; background-color: #2a2a2a; color: #c0c0c0; font-weight: bold; border-radius: 8px; cursor: pointer; transition: all 0.2s; }
        .mode-btn.active { background-color: #a16207; border-color: #f59e0b; color: white; }

        /* Estilos para o tooltip da profecia cooperativa */
        .coop-prophecy {
            position: relative;
            cursor: help;
        }
        .coop-prophecy .tooltip {
            visibility: hidden;
            width: 250px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 10;
            bottom: 125%;
            left: 50%;
            margin-left: -125px;
            opacity: 0;
            transition: opacity 0.3s;
            text-decoration: none; /* Garante que o texto do tooltip não seja riscado */
        }
        .coop-prophecy:hover:not(.prophecy-completed) .tooltip {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div id="game-container" class="max-w-7xl mx-auto">
        <div class="text-center mb-6">
            <h1 class="text-4xl font-bold text-amber-200">Goetia</h1>
            <p class="text-lg text-gray-400">Protótipo Online</p>
        </div>

        <!-- Lobby -->
        <div id="lobby" class="text-center bg-gray-900 p-8 rounded-lg max-w-lg mx-auto">
             <h2 class="text-2xl font-bold text-amber-300 mb-4">Modo de Jogo</h2>
             <div class="game-mode-selector">
                <button id="mode-competitive-btn" class="mode-btn active">Competitivo</button>
                <button id="mode-cooperative-btn" class="mode-btn">Cooperativo</button>
             </div>
             <hr class="border-gray-700 my-6">
              <h2 class="text-2xl font-bold text-amber-300 mb-4">Seu Nome</h2>
              <input type="text" id="player-name-input" placeholder="Digite seu nome aqui" class="w-full bg-gray-800 border border-gray-600 text-white p-2 rounded mb-6" maxlength="20">
             <h2 class="text-2xl font-bold text-amber-300 mb-4">Sala de Jogo</h2>
             <button id="create-game-btn" class="w-full mb-4 px-6 py-2 bg-amber-700 hover:bg-amber-600 text-white font-bold rounded-lg shadow-lg">Criar Novo Jogo</button>
             <div id="game-id-section" class="hidden mb-4">
                 <p class="text-gray-300">Compartilhe este ID com seu oponente:</p>
                 <p id="game-id-display" class="bg-gray-800 text-amber-200 font-mono p-2 rounded mt-2"></p>
             </div>
             <hr class="border-gray-700 my-6">
             <input type="text" id="join-game-input" placeholder="Cole o ID do Jogo aqui" class="w-full bg-gray-800 border border-gray-600 text-white p-2 rounded mb-4">
             <button id="join-game-btn" class="w-full px-6 py-2 bg-blue-700 hover:bg-blue-600 text-white font-bold rounded-lg shadow-lg">Entrar no Jogo</button>
        </div>

        <!-- Game Board -->
        <div id="game-board" class="hidden">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                <div class="flex flex-col items-center justify-center game-board-element p-4 rounded-lg">
                    <h3 class="text-xl font-bold text-amber-300 mb-2">Grimório</h3>
                    <p id="deck-count" class="text-2xl font-mono">100</p>
                </div>
                <div id="turn-display" class="flex flex-col items-center justify-center bg-gray-800 p-4 rounded-lg">
                     <h2 id="turn-indicator" class="text-2xl font-bold text-center text-amber-400">Turno 1</h2>
                     <p id="player-turn" class="text-gray-300">Aguardando Oponente...</p>
                </div>
                <div class="flex flex-col items-center justify-center game-board-element p-4 rounded-lg">
                    <h3 class="text-xl font-bold text-amber-300 mb-2">Monte de Descarte</h3>
                    <div id="discard-pile-card" class="card-button text-center min-h-[50px] flex items-center justify-center"></div>
                </div>
            </div>

            <!-- CO-OP Prophecy Board -->
            <div id="coop-board-container" class="hidden bg-gray-800 p-4 rounded-lg mb-6">
                <h3 class="text-xl font-bold text-center text-amber-300 mb-2">Profecias Compartilhadas</h3>
                <p class="text-center text-lg mb-4">Progresso: <span id="coop-prophecy-progress" class="font-bold text-green-400">0 / 5</span></p>
                <div id="coop-prophecies" class="flex flex-wrap justify-center gap-2">
                    <!-- Profecias cooperativas serão injetadas aqui -->
                </div>
            </div>
            
            <!-- Domain Board -->
            <div id="domain-board-container" class="bg-gray-800 p-4 rounded-lg mb-6">
                <h3 class="text-xl font-bold text-center text-amber-300 mb-2">Domínio Atual</h3>
                <div id="domain-board-cards" class="flex flex-wrap justify-center gap-2 min-h-[30px]"></div>
            </div>

            <!-- Player Areas -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Player 1 Area -->
                <div id="player1-area" class="bg-gray-900 p-6 rounded-lg border-2 border-transparent turn-indicator">
                    <h2 class="text-2xl font-bold mb-3 text-blue-300">Jogador 1</h2>
                    <div id="player1-hand" class="mb-4 min-h-[100px] flex flex-wrap"></div>
                    <div id="player1-prophecy-area" class="bg-gray-800 p-3 rounded">
                        <h4 class="font-bold mb-2 text-blue-200">Profecias Secretas:</h4>
                        <ul id="player1-prophecies" class="list-disc list-inside prophecy-list"></ul>
                    </div>
                     <div class="mt-4">
                         <h4 class="font-bold text-blue-200">Domínios Capturados: <span id="player1-dominions">0</span></h4>
                     </div>
                </div>
                <!-- Player 2 Area -->
                <div id="player2-area" class="bg-gray-900 p-6 rounded-lg border-2 border-transparent turn-indicator">
                    <h2 class="text-2xl font-bold mb-3 text-green-300">Jogador 2</h2>
                    <div id="player2-hand" class="mb-4 min-h-[100px] flex flex-wrap"></div>
                    <div id="player2-prophecy-area" class="bg-gray-800 p-3 rounded">
                        <h4 class="font-bold mb-2 text-green-200">Profecias Secretas:</h4>
                        <ul id="player2-prophecies" class="list-disc list-inside prophecy-list"></ul>
                    </div>
                     <div class="mt-4">
                         <h4 class="font-bold text-green-200">Domínios Capturados: <span id="player2-dominions">0</span></h4>
                     </div>
                </div>
            </div>

            <!-- Log and Chat Area Container -->
            <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Log Area -->
                <div>
                    <h3 class="text-xl font-bold mb-2 text-amber-300">Log da Partida</h3>
                    <div id="log-area" class="log-area rounded-lg"></div>
                </div>
                <!-- Chat Area -->
                <div>
                    <h3 class="text-xl font-bold mb-2 text-amber-300">Chat</h3>
                    <div id="chat-area" class="chat-area rounded-t-lg"></div>
                    <div class="flex">
                        <input type="text" id="chat-input" placeholder="Digite sua mensagem..." class="flex-grow bg-gray-800 border border-gray-600 text-white p-2 focus:outline-none focus:border-amber-500 rounded-bl-lg">
                        <button id="send-chat-btn" class="px-4 py-2 bg-amber-700 hover:bg-amber-600 text-white font-bold rounded-br-lg">Enviar</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Modals -->
        <div id="end-game-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-gray-900 p-8 rounded-lg shadow-2xl text-center border-2 border-amber-500">
                <h2 id="winner-text" class="text-3xl font-bold text-amber-300 mb-4"></h2>
                <p id="win-reason-text" class="text-gray-300 mb-6"></p>
                <button onclick="window.location.reload()" class="px-6 py-2 bg-amber-700 hover:bg-amber-600 text-white font-bold rounded-lg">Jogar Novamente</button>
            </div>
        </div>

        <!-- Seal Decision Modal -->
        <div id="seal-decision-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-gray-800 p-8 rounded-lg shadow-2xl text-center border-2 border-yellow-500">
                <h2 class="text-2xl font-bold text-yellow-300 mb-4">Oponente jogou um Rei!</h2>
                <p id="seal-modal-text" class="text-gray-300 mb-6">Você deseja usar o seu Selo de Salomão para roubar este Domínio?</p>
                <div class="flex justify-center space-x-4">
                    <button id="confirm-seal-btn" class="px-6 py-2 bg-green-600 hover:bg-green-500 text-white font-bold rounded-lg">Sim, Usar Selo</button>
                    <button id="decline-seal-btn" class="px-6 py-2 bg-red-700 hover:bg-red-600 text-white font-bold rounded-lg">Não, Passar</button>
                </div>
            </div>
        </div>

        <!-- Prophecy Choice Modal -->
        <div id="prophecy-choice-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-gray-800 p-8 rounded-lg shadow-2xl text-center border-2 border-purple-500 max-w-lg">
                <h2 id="prophecy-modal-title" class="text-2xl font-bold text-purple-300 mb-4">Múltiplas Profecias Cumpridas!</h2>
                <p id="prophecy-modal-text" class="text-gray-300 mb-6">Escolha qual profecia deseja registrar:</p>
                <div id="prophecy-options" class="space-y-3 mb-6 text-left"></div>
                <p id="prophecy-vote-status" class="text-gray-400 text-sm mb-4 hidden"></p>
                <button id="confirm-prophecy-btn" class="px-6 py-2 bg-purple-600 hover:bg-purple-500 text-white font-bold rounded-lg w-full">Confirmar</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        
        document.addEventListener('DOMContentLoaded', async () => {
            const firebaseConfig = {
              apiKey: "AIzaSyDkF5F_4wL1tE-BK6J6UnZInENW5rOOA3I",
              authDomain: "dominio-acb39.firebaseapp.com",
              projectId: "dominio-acb39",
              storageBucket: "dominio-acb39.firebasestorage.app",
              messagingSenderId: "287882033315",
              appId: "1:287882033315:web:58ba0964bc17c8e008a716",
              measurementId: "G-018FBT2E4V"
            };
            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);
            const auth = getAuth(app);
            
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Authentication failed:", error);
                document.body.innerHTML = `<div class="text-center text-red-500 p-8">Erro de Autenticação.</div>`;
                return;
            }

            const appId = typeof __app_id !== 'undefined' ? __app_id : 'ars-goetia-default';
            const gamesCollectionPath = `/artifacts/${appId}/public/data/ars_goetia_games`;
            
            // DATA (Completo)
            const demons = [
                {Nome:"Bael", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Riqueza"},
                {Nome:"Paimon", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Conhecimento"},
                {Nome:"Beleth", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Riqueza"},
                {Nome:"Purson", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Conhecimento"},
                {Nome:"Asmoday", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Guerra"},
                {Nome:"Vine", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Guerra"},
                {Nome:"Balam", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Conhecimento"},
                {Nome:"Zagan", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Riqueza"},
                {Nome:"Belial", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Riqueza"},
                {Nome:"Vassago", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Conhecimento"},
                {Nome:"Ipos", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Conhecimento"},
                {Nome:"Stolas", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Guerra"},
                {Nome:"Orobas", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Guerra"},
                {Nome:"Agares", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Conhecimento"},
                {Nome:"Valefor", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"},
                {Nome:"Barbatos", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"},
                {Nome:"Bathin", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Guerra"},
                {Nome:"Saleos", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"},
                {Nome:"Berith", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"},
                {Nome:"Astaroth", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Conhecimento"},
                {Nome:"Vepar", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Guerra"},
                {Nome:"Vual", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"},
                {Nome:"Murmur", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Conhecimento"},
                {Nome:"Gremory", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"},
                {Nome:"Haures", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Guerra"},
                {Nome:"Amduscias", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Guerra"},
                {Nome:"Dantalion", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"},
                {Nome:"Aim", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Guerra"},
                {Nome:"Amon", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Riqueza"},
                {Nome:"Naberius", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Conhecimento"},
                {Nome:"Forneus", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Riqueza"},
                {Nome:"Phenex", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Conhecimento"},
                {Nome:"Orias", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Conhecimento"},
                {Nome:"Andras", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Guerra"},
                {Nome:"Andrealphus", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Conhecimento"},
                {Nome:"Cimeies", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Guerra"},
                {Nome:"Decarabia", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Guerra"},
                {Nome:"Botis", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Riqueza"},
                {Nome:"Glasya-Labolas", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Conhecimento"},
                {Nome:"Ronove", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Guerra"},
                {Nome:"Furfur", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Guerra"},
                {Nome:"Halphas", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Guerra"},
                {Nome:"Andromalius", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Riqueza"},
                {Nome:"Furcas", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Conhecimento"},
                {Nome:"Leraje", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Guerra"},
                {Nome:"Foras", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Riqueza"},
                {Nome:"Gaap", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Conhecimento"},
                {Nome:"Malphas", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Guerra"},
                {Nome:"Ose", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Conhecimento"},
                {Nome:"Amy", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Riqueza"},
                {Nome:"Valac", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Riqueza"}
            ];
            const metals = [...Array(4).fill({Nome: "Cobre", Título: "Duque"}), ...Array(5).fill({Nome: "Prata", Título: "Marquês"}), ...Array(4).fill({Nome: "Mercúrio", Título: "Presidente"}), ...Array(5).fill({Nome: "Estanho", Título: "Conde"})];
            const seals = Array(2).fill({Nome: "Selo de Salomão"});
            const allProphecies = [
                { id: 'p1', Nome: 'A Aristocracia Perversa', Desc: 'Capture um domínio com ao menos 4 demônios da afinidade Riqueza.', check: (domain) => domain.filter(c => c.Tipo === 'Demonio' && c.Afinidade === 'Riqueza').length >= 4 },
                { id: 'p2', Nome: 'O Monólito Vermelho', Desc: 'Capture um Domínio onde TODOS os demônios são da afinidade Guerra.', check: (domain) => domain.filter(c => c.Tipo === 'Demonio' && c.Hierarquia !== 'Alta').every(c => c.Afinidade === 'Guerra') && domain.filter(c => c.Tipo === 'Demonio').length > 0 },
                { id: 'p3', Nome: 'A Insurreição dos Iguais', Desc: 'Capture um Domínio com >= 7 cartas, onde TODOS os demônios (exceto Reis) são da mesma Hierarquia (Baixa ou Média).', check: (domain) => { const demons = domain.filter(c => c.Tipo === 'Demonio' && c.Hierarquia !== 'Alta'); return domain.length >= 7 && (demons.length > 0 && (demons.every(d => d.Hierarquia === 'Baixa') || demons.every(d => d.Hierarquia === 'Média')) ); } },
                { id: 'p4', Nome: 'A Pirâmide Perfeita', Desc: 'Capture um Domínio que contenha em ordem sequencial (ignorando metais) Presidente -> Conde -> Marquês.', check: (domain) => { const demons = domain.filter(c => c.Tipo === 'Demonio'); const titles = demons.map(d => d.Título).join(','); return titles.includes('Presidente,Conde,Marquês'); } },
                { id: 'p5', Nome: 'O Tesouro Profano', Desc: 'Capture um Domínio onde mais da metade das cartas são Metais.', check: (domain) => domain.filter(c => c.Tipo === 'Metal').length > domain.length / 2 },
                { id: 'p6', Nome: 'O Mosaico do Caos', Desc: 'Capture um Domínio com >= 6 demônios, sem que nenhuma Afinidade apareça mais do que duas vezes.', check: (domain) => { const demons = domain.filter(c => c.Tipo === 'Demonio'); const counts = demons.reduce((acc, d) => { acc[d.Afinidade] = (acc[d.Afinidade] || 0) + 1; return acc; }, {}); return demons.length >= 6 && Object.values(counts).every(v => v <= 2); } },
                { id: 'p7', Nome: 'A Trindade Completa', Desc: 'Capture um Domínio que contenha EXATAMENTE um demônio de cada Afinidade.', check: (domain) => { const demons = domain.filter(c => c.Tipo === 'Demonio'); const affinities = new Set(demons.map(d => d.Afinidade)); return demons.length === 3 && affinities.size === 3; } },
                { id: 'p8', Nome: 'O Salto da Fé', Desc: 'Capture um Domínio com um Duque, onde TODOS os outros demônios são de Baixa Hierarquia e tenha ao menos 4 demônios.', check: (domain) => { const demons = domain.filter(c => c.Tipo === 'Demonio' && c.Hierarquia !== 'Alta'); return demons.length >= 4 && demons.some(d => d.Hierarquia === 'Média') && demons.filter(d => d.Hierarquia === 'Baixa').length === (demons.length - 1); } },
                { id: 'p9', Nome: 'A Prata Romana', Desc: 'Capture um domínio que tenha ao menos 3 cartas de Prata.', check: (domain) => domain.filter(c => c.Tipo === 'Metal' && c.Nome === 'Prata').length >= 3 },
                { id: 'p10', Nome: 'A Liga Infernal', Desc: 'Capture um Domínio que contenha pelo menos um de cada um dos 4 tipos de Metal.', check: (domain) => { const metalTypes = new Set(domain.filter(c => c.Tipo === 'Metal').map(m => m.Nome)); return metalTypes.size === 4; } },
                { id: 'p11', Nome: 'A Legião Pura', Desc: 'Capture um Domínio que não contenha NENHUMA carta de Metal.', check: (domain) => domain.filter(c => c.Tipo === 'Metal').length === 0 },
                { id: 'p12', Nome: 'O Segredo de Astaroth', Desc: 'Capture um Domínio que contenha o Duque Astaroth e >= 2 outros demônios de Conhecimento.', check: (domain) => domain.some(c => c.Nome === 'Astaroth') && domain.filter(c => c.Tipo === 'Demonio' && c.Afinidade === 'Conhecimento').length >= 3 },
                { id: 'p13', Nome: 'A Orquestra de Amduscias', Desc: 'Capture um Domínio que contenha o Duque Amduscias e demônios de >= 2 outros Títulos.', check: (domain) => { const titles = new Set(domain.filter(c => c.Tipo === 'Demonio').map(d => d.Título)); return domain.some(c => c.Nome === 'Amduscias') && titles.size >= 3; } },
                { id: 'p14', Nome: 'A Corrupção do Sábio', Desc: 'Cumprida se o Selo de Salomão for utilizado.', check: () => false, event: 'selo_played' },
                { id: 'p15', Nome: 'O Servo de Bael', Desc: 'Cumprida quando um Domínio é capturado usando o Rei Bael.', check: (domain) => { const capturingKing = domain[domain.length - 1]; return capturingKing && capturingKing.Nome === 'Bael'; } },
                { id: 'p16', Nome: 'O Grito do Abismo', Desc: 'Cumprida se você for forçado a fazer um Sacrifício.', check: () => false, event: 'sacrifice_made' },
                { id: 'p17', Nome: 'A Escala da Loucura', Desc: 'Cumprida se você jogar o 3º demônio consecutivo da mesma Afinidade.', check: () => false, event: 'affinity_streak' },
                { id: 'p18', Nome: 'O Mestre dos Marionetes', Desc: 'Capture um Domínio onde o primeiro Duque foi jogado por um oponente.', check: (domain, player, history) => { const firstDukePlay = history.find(play => play.card.Título === 'Duque'); return firstDukePlay && firstDukePlay.player !== player; } },
            ];

            // GLOBAL VARS
            let localGameState = {};
            let localPlayerId = null;
            let gameId = null;
            let unsubscribe = null;
            let sacrificeSelection = [];
            let selectedGameMode = 'competitive'; // Default game mode

            // HIERARCHY MAPS
            const titleHierarchy = { 'Presidente': 1, 'Conde': 2, 'Marquês': 3, 'Duque': 4 };
            const metalHierarchy = { 'Mercúrio': 1, 'Estanho': 2, 'Prata': 3, 'Cobre': 4 };

            // UTILITY FUNCTIONS
            function getPlayerName(playerNumber, state) {
                return state[`player${playerNumber}`]?.name || `Jogador ${playerNumber}`;
            }
            
            function getProphecyDetails(id) {
                return allProphecies.find(p => p.id === id);
            }

            function formatCardData(card) {
                if (!card) return { displayText: 'Monte Vazio' };
                let text = card.Nome;
                if (card.Tipo === 'Demonio') {
                    text = `${card.Nome} (${card.Título}, ${card.Afinidade}${card.Metal ? ', ' + card.Metal : ''})`;
                } else if (card.Tipo === 'Metal') {
                    text = `Metal: ${card.Nome}`;
                }
                return { ...card, displayText: text };
            }

            async function updateFirestore(newState) {
                if (gameId) {
                    try {
                        const gameRef = doc(db, gamesCollectionPath, gameId);
                        await setDoc(gameRef, newState);
                    } catch (e) {
                        console.error("Error writing to Firestore: ", e);
                        addLogToState(localGameState, "ERRO: Não foi possível sincronizar.");
                        updateUI();
                    }
                }
            }

            function addLogToState(state, message, options) {
                if (!state.log) state.log = [];
                state.log.unshift({ text: message, type: options?.type || 'normal' });
                if (state.log.length > 30) state.log.pop();
            }

            function showCustomAlert(message) {
                const alertBox = document.createElement('div');
                alertBox.style.cssText = 'position:fixed; top:20px; left:50%; transform:translateX(-50%); background-color:#f8d7da; color:#721c24; padding:1rem; border:1px solid #f5c6cb; border-radius:0.25rem; z-index:1000;';
                alertBox.textContent = message;
                document.body.appendChild(alertBox);
                setTimeout(() => {
                    alertBox.remove();
                }, 3000);
            }

            // GAME LOGIC FUNCTIONS
            function isLegalMove(cardToPlay, topCard) {
                // Se for a primeira jogada do jogo (não há carta no topo)
                if (!topCard) {
                    // A primeira carta não pode ser um Rei.
                    return cardToPlay.Título !== 'Rei';
                }
            
                // Lógica original para as jogadas seguintes
                if (cardToPlay.Tipo === 'Lendário') return false;
                if (cardToPlay.Título === 'Rei') return true;
                if (cardToPlay.Tipo === 'Demonio' && topCard.Tipo === 'Demonio') {
                    const playTitleRank = titleHierarchy[cardToPlay.Título] || 0;
                    const topTitleRank = titleHierarchy[topCard.Título] || 0;
                    if (playTitleRank > topTitleRank) return true;
                }
                if (cardToPlay.Título && cardToPlay.Título === topCard.Título) return true;
                if (cardToPlay.Tipo === 'Demonio' && topCard.Tipo === 'Metal') {
                    if (cardToPlay.Metal && cardToPlay.Metal === topCard.Nome) return true;
                }
                if (cardToPlay.Tipo === 'Metal' && topCard.Tipo === 'Metal') {
                    const playMetalRank = metalHierarchy[cardToPlay.Nome] || 0;
                    const topMetalRank = metalHierarchy[topCard.Nome] || 0;
                    if (playMetalRank > topMetalRank) return true;
                }
                return false;
            }

            function checkEventProphecies(eventName, playerNumber, state) {
                const playerId = `player${playerNumber}`;
                let fulfilled = false;
                state[playerId].prophecies.forEach(p => {
                    const details = getProphecyDetails(p.id);
                    if (!p.completed && details && details.event === eventName) {
                        p.completed = true;
                        fulfilled = true;
                        addLogToState(state, `${getPlayerName(playerNumber, state)} cumpriu a profecia: ${details.Nome}!`);
                    }
                });
                if (fulfilled) checkWinCondition(state);
            }
            
            function findFulfillableDomainProphecies(playerNumber, domain, history, state) {
                const prophecyList = state.gameMode === 'cooperative' ? state.sharedProphecies : state[`player${playerNumber}`].prophecies;
                const uncompleted = prophecyList.filter(p => !p.completed);
                if (uncompleted.length === 0) return [];

                const fulfilled = [];
                for (const p of uncompleted) {
                    const details = getProphecyDetails(p.id);
                    if (details && !details.event && details.check(domain, playerNumber, history)) {
                        fulfilled.push(p.id);
                    }
                }
                return fulfilled;
            }

            function checkWinCondition(state) {
                if (state.game_over) return false;
                
                let winner = null;
                let reason = '';

                if (state.gameMode === 'cooperative') {
                    const completedCount = state.sharedProphecies.filter(p => p.completed).length;
                    if (completedCount >= 5) {
                        winner = 0; // 0 for co-op win
                        reason = 'Ascensão Cooperativa';
                    } else if (state.deck.length === 0 && (state.turn_count-1) % 2 !== 0 && state.current_player === 1) {
                        winner = -1; // -1 for co-op loss
                        reason = 'Esgotamento';
                    }
                } else { // Competitive mode
                    let p1Score = state.player1.prophecies.filter(p => p.completed).length;
                    let p2Score = state.player2.prophecies.filter(p => p.completed).length;
                    if (p1Score >= 3) {
                        winner = 1;
                        reason = 'Ascensão';
                    } else if (p2Score >= 3) {
                        winner = 2;
                        reason = 'Ascensão';
                    } else if (state.deck.length === 0 && (state.turn_count-1) % 2 !== 0 && state.current_player === 1) {
                        reason = 'Esgotamento';
                        if (p1Score > p2Score) winner = 1;
                        else if (p2Score > p1Score) winner = 2;
                        else winner = 0; // Tie
                    }
                }
                
                if(winner !== null) {
                    state.game_over = true;
                    state.winner = winner;
                    state.win_reason = reason;
                    return true;
                }
                return false;
            }

            function endGameUI(winner, reason, gameMode, state) {
                const winnerText = document.getElementById('winner-text');
                const reasonText = document.getElementById('win-reason-text');
                
                if (gameMode === 'cooperative') {
                    winnerText.textContent = winner === 0 ? "Vitória Cooperativa!" : "Derrota...";
                } else {
                    const winnerName = getPlayerName(winner, state);
                    winnerText.textContent = winner === 0 ? "Empate!" : `${winnerName} Venceu!`;
                }

                let reasonMessage = '';
                switch(reason) {
                    case 'Ascensão Cooperativa':
                        reasonMessage = 'Vocês ascenderam juntos ao cumprir 5 profecias!';
                        break;
                    case 'Ascensão':
                        reasonMessage = 'O Mestre ascendeu ao cumprir três profecias.';
                        break;
                    case 'Esgotamento':
                        reasonMessage = gameMode === 'cooperative' ? 'O grimório se esgotou antes de cumprirem o ritual.' : 'O grimório se esgotou. A vitória foi decidida por profecias.';
                        break;
                    case 'Aniquilação':
                        reasonMessage = gameMode === 'cooperative' ? 'Um dos jogadores foi aniquilado, encerrando o ritual.' : 'O oponente não pôde continuar e foi aniquilado.';
                        break;
                    default:
                        reasonMessage = 'O jogo terminou.';
                }
                reasonText.textContent = reasonMessage;
                document.getElementById('end-game-modal').classList.remove('hidden');
            }

            function updateUI() {
                if (!localGameState.deck || !localPlayerId) return;

                const currentPlayerNumber = localGameState.current_player;
                const localPlayerNumber = localPlayerId === 'player1' ? 1 : 2;
                const isMyTurn = currentPlayerNumber === localPlayerNumber && !(localGameState.seal_decision?.active) && !(localGameState.prophecy_choice?.active);
                
                // Update UI based on game mode
                const isCoop = localGameState.gameMode === 'cooperative';
                document.getElementById('coop-board-container').classList.toggle('hidden', !isCoop);
                document.getElementById('player1-prophecy-area').classList.toggle('hidden', isCoop);
                document.getElementById('player2-prophecy-area').classList.toggle('hidden', isCoop);

                if (isCoop) {
                    const completedCount = localGameState.sharedProphecies.filter(p => p.completed).length;
                    document.getElementById('coop-prophecy-progress').textContent = `${completedCount} / 5`;
                    const coopPropheciesContainer = document.getElementById('coop-prophecies');
                    coopPropheciesContainer.innerHTML = '';
                    localGameState.sharedProphecies.forEach(p => {
                        const details = getProphecyDetails(p.id);
                        const pElem = document.createElement('div');
                        pElem.className = `coop-prophecy p-2 rounded border ${p.completed ? 'bg-green-900 border-green-500' : 'bg-gray-700 border-gray-500'}`;
                        pElem.innerHTML = `<span class="font-bold">${details.Nome}</span><span class="tooltip">${details.Desc}</span>`;
                        if (p.completed) {
                            pElem.classList.add('prophecy-completed');
                            pElem.style.cursor = 'default';
                        }
                        coopPropheciesContainer.appendChild(pElem);
                    });
                }
                
                const p1Name = localGameState.player1.name;
                const p2Name = localGameState.player2.name;

                document.getElementById('player1-area').querySelector('h2').textContent = `${p1Name} ${localPlayerId === 'player1' ? '(Você)' : ''}`;
                document.getElementById('player2-area').querySelector('h2').textContent = `${p2Name} ${localPlayerId === 'player2' ? '(Você)' : ''}`;
                document.getElementById('turn-indicator').textContent = `Turno ${localGameState.turn_count}`;
                
                let turnText = localGameState.status === 'waiting' ? 'Aguardando oponente...' : '';
                if (localGameState.status === 'active' && !turnText) {
                    const isSealDecisionTime = localGameState.seal_decision?.active;
                    const isProphecyChoiceTime = localGameState.prophecy_choice?.active;
                    if (isSealDecisionTime) {
                        turnText = localGameState.seal_decision.player === localPlayerNumber ? 'Sua decisão: Usar o Selo?' : 'Aguardando decisão do oponente...';
                    } else if (isProphecyChoiceTime) {
                        turnText = 'Momento de Decisão da Profecia...';
                    } else if (isMyTurn) {
                        turnText = "É A SUA VEZ!";
                    } else {
                        const currentTurnPlayerName = getPlayerName(currentPlayerNumber, localGameState);
                        turnText = `Vez de ${currentTurnPlayerName}`;
                    }
                }
                document.getElementById('player-turn').textContent = turnText;

                document.getElementById('player1-area').style.borderColor = currentPlayerNumber === 1 ? '#f59e0b' : 'transparent';
                document.getElementById('player2-area').style.borderColor = currentPlayerNumber === 2 ? '#f59e0b' : 'transparent';
                document.getElementById('deck-count').textContent = localGameState.deck.length;
                const topCard = localGameState.discard_pile.length > 0 ? localGameState.discard_pile[localGameState.discard_pile.length - 1] : null;
                document.getElementById('discard-pile-card').textContent = topCard ? formatCardData(topCard).displayText : 'Monte Vazio';
                
                const logArea = document.getElementById('log-area');
                logArea.innerHTML = '';
                (localGameState.log || []).forEach(logEntry => {
                    const p = document.createElement('p');
                    if (logEntry.type === 'capture') {
                        p.innerHTML = `> <strong>${logEntry.text}</strong>`;
                    } else {
                        p.textContent = `> ${logEntry.text}`;
                    }
                    logArea.appendChild(p);
                });

                const domainBoard = document.getElementById('domain-board-cards');
                domainBoard.innerHTML = '';
                if (localGameState.discard_pile && localGameState.discard_pile.length > 0) {
                    localGameState.discard_pile.forEach(card => {
                        const cardElement = document.createElement('div');
                        cardElement.className = 'domain-card-item';
                        cardElement.textContent = formatCardData(card).displayText;
                        domainBoard.appendChild(cardElement);
                    });
                }

                const chatInput = document.getElementById('chat-input');
                const sendChatBtn = document.getElementById('send-chat-btn');
                const chatEnabled = isCoop ? localGameState.prophecy_choice?.active : true;
                chatInput.disabled = !chatEnabled;
                sendChatBtn.disabled = !chatEnabled;
                chatInput.placeholder = chatEnabled ? "Digite sua mensagem..." : "O chat está selado...";

                const chatArea = document.getElementById('chat-area');
                chatArea.innerHTML = '';
                (localGameState.chat || []).forEach(msg => {
                    const msgDiv = document.createElement('div');
                    msgDiv.className = `chat-message ${msg.senderId}`;
                    msgDiv.innerHTML = `<span class="sender">${msg.sender}</span>${msg.text}`;
                    chatArea.appendChild(msgDiv);
                });
                chatArea.scrollTop = chatArea.scrollHeight;

                ['player1', 'player2'].forEach(pid => {
                    const handContainer = document.getElementById(`${pid}-hand`);
                    handContainer.innerHTML = '';
                    const handData = localGameState[pid].hand;
                    if (localPlayerId === pid) {
                        handData.forEach((card, index) => {
                            const btn = document.createElement('button');
                            btn.className = 'card-button';
                            if (sacrificeSelection.includes(index) && isMyTurn) btn.classList.add('sacrificing');
                            btn.textContent = formatCardData(card).displayText;
                            btn.onclick = () => handleCardClick(localPlayerNumber, index);
                            btn.disabled = !isMyTurn;
                            handContainer.appendChild(btn);
                        });
                    } else {
                        for(let i=0; i < handData.length; i++) {
                            const cardPlaceholder = document.createElement('div');
                            cardPlaceholder.className = 'card-button opponent-card flex items-center justify-center';
                            cardPlaceholder.textContent = `Oculta`;
                            handContainer.appendChild(cardPlaceholder);
                        }
                    }
                    
                    if (!isCoop) {
                        const propheciesContainer = document.getElementById(`${pid}-prophecies`);
                        propheciesContainer.innerHTML = '';
                        localGameState[pid].prophecies.forEach(p => {
                            const details = getProphecyDetails(p.id);
                            if (!details) return;
                            const li = document.createElement('li');
                            if (localPlayerId === pid) {
                                li.textContent = details.Nome;
                                const tooltip = document.createElement('span');
                                tooltip.className = 'tooltip';
                                tooltip.textContent = details.Desc;
                                li.appendChild(tooltip);
                            } else {
                                li.textContent = "Profecia Oculta";
                            }
                            if (p.completed) li.classList.add('prophecy-completed');
                            propheciesContainer.appendChild(li);
                        });
                    }
                    document.getElementById(`${pid}-dominions`).textContent = localGameState[pid].domains_captured;
                });

                const sealModal = document.getElementById('seal-decision-modal');
                const isSealDecisionTime = localGameState.seal_decision?.active;
                const amITheSealDecider = isSealDecisionTime && localGameState.seal_decision.player === localPlayerNumber;
                if (amITheSealDecider) {
                    const iHaveTheSeal = localGameState[localPlayerId].hand.some(c => c.Nome === 'Selo de Salomão');
                    const confirmBtn = document.getElementById('confirm-seal-btn');
                    const declineBtn = document.getElementById('decline-seal-btn');
                    const modalText = document.getElementById('seal-modal-text');
                    if (iHaveTheSeal) {
                        modalText.textContent = 'Você deseja usar o seu Selo de Salomão?';
                        confirmBtn.classList.remove('hidden');
                        declineBtn.textContent = 'Não, Passar';
                    } else {
                        modalText.textContent = 'Você não possui o Selo de Salomão.';
                        confirmBtn.classList.add('hidden');
                        declineBtn.textContent = 'Continuar';
                    }
                    sealModal.classList.remove('hidden');
                } else {
                    sealModal.classList.add('hidden');
                }
                
                const prophecyModal = document.getElementById('prophecy-choice-modal');
                const isProphecyChoiceTime = localGameState.prophecy_choice?.active;
                const amITheProphecyDecider = isProphecyChoiceTime && (isCoop || localGameState.prophecy_choice.player === localPlayerNumber);
                if(amITheProphecyDecider) {
                    const optionsContainer = document.getElementById('prophecy-options');
                    const voteStatus = document.getElementById('prophecy-vote-status');
                    optionsContainer.innerHTML = '';
                    localGameState.prophecy_choice.choices.forEach((pId, index) => {
                        const details = getProphecyDetails(pId);
                        const wrapper = document.createElement('div');
                        const radio = document.createElement('input');
                        radio.type = 'radio';
                        radio.id = `prophecy-radio-${pId}`;
                        radio.name = 'prophecy-selection';
                        radio.value = pId;
                        if (index === 0) radio.checked = true;
                        const label = document.createElement('label');
                        label.htmlFor = `prophecy-radio-${pId}`;
                        label.className = 'prophecy-choice-label';
                        label.innerHTML = `<strong class="text-purple-300">${details.Nome}</strong><br><small class="text-gray-400">${details.Desc}</small>`;
                        wrapper.appendChild(radio);
                        wrapper.appendChild(label);
                        optionsContainer.appendChild(wrapper);
                    });
                    
                    if (isCoop) {
                        document.getElementById('prophecy-modal-title').textContent = "Votação de Profecia!";
                        document.getElementById('prophecy-modal-text').textContent = "Comuniquem-se e votem em qual profecia registrar:";
                        document.getElementById('confirm-prophecy-btn').textContent = 'Votar';
                        const myVote = localGameState.prophecy_choice.votes[localPlayerId];
                        if (myVote) {
                            optionsContainer.querySelectorAll('input').forEach(r => r.disabled = true);
                            const myVotedLabel = document.querySelector(`label[for="prophecy-radio-${myVote}"]`);
                            if(myVotedLabel) myVotedLabel.style.borderColor = '#8b5cf6';
                            voteStatus.textContent = 'Você votou. Aguardando o outro jogador...';
                            voteStatus.classList.remove('hidden');
                        } else {
                            voteStatus.classList.add('hidden');
                        }
                    } else { // Reset for competitive mode
                        document.getElementById('prophecy-modal-title').textContent = "Múltiplas Profecias Cumpridas!";
                        document.getElementById('prophecy-modal-text').textContent = "Escolha qual profecia deseja registrar:";
                        document.getElementById('confirm-prophecy-btn').textContent = 'Confirmar';
                        voteStatus.classList.add('hidden');
                    }
                    
                    prophecyModal.classList.remove('hidden');
                } else {
                    prophecyModal.classList.add('hidden');
                }

                if (localGameState.game_over) {
                    endGameUI(localGameState.winner, localGameState.win_reason, localGameState.gameMode, localGameState);
                    if(unsubscribe) unsubscribe();
                }
            }
            
            async function handleCardClick(playerNumber, index) {
                const isMyTurn = localGameState.current_player === playerNumber && !(localGameState.seal_decision?.active) && !(localGameState.prophecy_choice?.active);
                if (localGameState.game_over || !isMyTurn) return;
                const hand = localGameState[localPlayerId].hand;
                const topCard = localGameState.discard_pile.length > 0 ? localGameState.discard_pile[localGameState.discard_pile.length - 1] : null;
                const hasLegalMoves = hand.some(card => isLegalMove(card, topCard));

                if (hasLegalMoves) {
                    const cardToPlay = hand[index];
                    if (isLegalMove(cardToPlay, topCard)) {
                        let newState = JSON.parse(JSON.stringify(localGameState));
                        await playCard(playerNumber, index, newState);
                    } else {
                        showCustomAlert("Jogada ilegal.");
                    }
                } else {
                    if (hand.length < 3) {
                        let newState = JSON.parse(JSON.stringify(localGameState));
                        const winner = localGameState.gameMode === 'cooperative' ? -1 : (playerNumber === 1 ? 2 : 1);
                        addLogToState(newState, `${getPlayerName(playerNumber, newState)} não pode sacrificar e perde por Aniquilação!`);
                        newState.game_over = true;
                        newState.winner = winner;
                        newState.win_reason = 'Aniquilação';
                        await updateFirestore(newState);
                        return;
                    }
                    addLogToState(localGameState, `${getPlayerName(playerNumber, localGameState)} não tem jogadas legais e precisa sacrificar 3 cartas.`);
                    if (!sacrificeSelection.includes(index)) {
                        sacrificeSelection.push(index);
                    } else {
                        sacrificeSelection = sacrificeSelection.filter(i => i !== index);
                    }
                    if (sacrificeSelection.length === 3) {
                        let newState = JSON.parse(JSON.stringify(localGameState));
                        await performSacrifice(playerNumber, newState);
                    } else {
                        updateUI();
                    }
                }
            }

            async function performSacrifice(playerNumber, state) {
                const playerName = getPlayerName(playerNumber, state);
                addLogToState(state, `${playerName} realiza um Sacrifício!`);
                if(state.gameMode === 'competitive') checkEventProphecies('sacrifice_made', playerNumber, state);
                const playerId = `player${playerNumber}`;
                const hand = state[playerId].hand;
                const cardToPlay = hand[sacrificeSelection[2]];
                const sortedIndices = sacrificeSelection.sort((a, b) => b - a);
                sortedIndices.forEach(index => hand.splice(index, 1));
                state.discard_pile.push(cardToPlay);
                state.play_history.push({ player: playerNumber, card: cardToPlay });
                addLogToState(state, `${playerName} joga (via Sacrifício): ${formatCardData(cardToPlay).displayText}`);
                sacrificeSelection = [];
                await handleEndOfTurn(playerNumber, cardToPlay, state);
            }

            async function playCard(playerNumber, index, state) {
                const playerId = `player${playerNumber}`;
                const playerName = getPlayerName(playerNumber, state);
                const cardToPlay = state[playerId].hand.splice(index, 1)[0];
                state.discard_pile.push(cardToPlay);
                state.play_history.push({ player: playerNumber, card: cardToPlay });
                addLogToState(state, `${playerName} joga: ${formatCardData(cardToPlay).displayText}`);
                if(state.gameMode === 'competitive') {
                    const history = state.play_history;
                    if (history.length >= 3 && cardToPlay.Tipo === 'Demonio') {
                        const last3Plays = history.slice(-3);
                        if (last3Plays.every(p => p.player === playerNumber && p.card.Tipo === 'Demonio' && p.card.Afinidade === cardToPlay.Afinidade)) {
                            checkEventProphecies('affinity_streak', playerNumber, state);
                        }
                    }
                }
                await handleEndOfTurn(playerNumber, cardToPlay, state);
            }

            async function handleEndOfTurn(playerNumber, playedCard, state) {
                if (playedCard.Título === 'Rei') {
                    const opponentNumber = playerNumber === 1 ? 2 : 1;
                    state.seal_decision = { active: true, player: opponentNumber, king_player: playerNumber };
                    await updateFirestore(state);
                } else {
                    advanceTurn(playerNumber, state);
                    if(!checkWinCondition(state)){
                        await updateFirestore(state);
                    } else {
                        await updateFirestore(state);
                    }
                }
            }

            function advanceTurn(lastPlayer, state) {
                const opponent = lastPlayer === 1 ? 2 : 1;
                const playerWhoDraws = state.current_player;
                if (state.deck.length > 0) {
                    const drawnCard = state.deck.pop();
                    state[`player${playerWhoDraws}`].hand.push(drawnCard);
                    addLogToState(state, `${getPlayerName(playerWhoDraws, state)} compra uma carta.`);
                } else {
                    addLogToState(state, "Grimório vazio!");
                }
                state.turn_count++;
                state.current_player = opponent;
                sacrificeSelection = [];
            }
            
            async function processDomainCapture(playerNumber, state) {
                const playerName = getPlayerName(playerNumber, state);
                addLogToState(state, `${playerName} captura um Domínio com ${state.discard_pile.length} cartas!`, { type: 'capture' });
                const capturedDomain = [...state.discard_pile];
                state.discard_pile = [];
                state.removed_from_game.push(...capturedDomain);
                state[`player${playerNumber}`].domains_captured++;
                if(state.gameMode === 'competitive') checkEventProphecies('domain_captured', playerNumber, state);
                
                const fulfillableProphecies = findFulfillableDomainProphecies(playerNumber, capturedDomain, state.play_history, state);
                
                if (fulfillableProphecies.length === 1) {
                    const prophecyId = fulfillableProphecies[0];
                    const prophecyList = state.gameMode === 'cooperative' ? state.sharedProphecies : state[`player${playerNumber}`].prophecies;
                    const prophecy = prophecyList.find(p => p.id === prophecyId);
                    if (prophecy) {
                        prophecy.completed = true;
                        addLogToState(state, `Profecia cumprida: ${getProphecyDetails(prophecyId).Nome}!`);
                    }
                    if (checkWinCondition(state)) {
                        await updateFirestore(state);
                        return;
                    }
                    advanceTurn(playerNumber, state);
                    await updateFirestore(state);

                } else if (fulfillableProphecies.length > 1) {
                    state.prophecy_choice = { active: true, player: playerNumber, choices: fulfillableProphecies, domain_owner: playerNumber, votes: { player1: null, player2: null } };
                    addLogToState(state, `Múltiplas profecias cumpridas! Momento de decisão.`);
                    await updateFirestore(state);

                } else {
                    advanceTurn(playerNumber, state);
                    await updateFirestore(state);
                }
            }
            
            async function handleSelo(playerNumber) {
                if (localGameState.game_over) return;
                let newState = JSON.parse(JSON.stringify(localGameState));
                const kingPlayerNumber = newState.seal_decision.king_player;
                const playerName = getPlayerName(playerNumber, newState);
                addLogToState(newState, `${playerName} usa o Selo de Salomão!`);
                const seloIndex = newState[`player${playerNumber}`].hand.findIndex(c => c.Nome === 'Selo de Salomão');
                if(seloIndex === -1) return;
                newState[`player${playerNumber}`].hand.splice(seloIndex, 1)[0];
                newState.seal_decision = { active: false, player: null, king_player: null };
                if(newState.gameMode === 'competitive') {
                    checkEventProphecies('selo_played', playerNumber, newState);
                    checkEventProphecies('selo_played', kingPlayerNumber, newState);
                }
                await processDomainCapture(playerNumber, newState);
            }

            async function handleDeclineSelo(decliningPlayerNumber) {
                let newState = JSON.parse(JSON.stringify(localGameState));
                const kingPlayerNumber = newState.seal_decision.king_player;
                const playerName = getPlayerName(decliningPlayerNumber, newState);
                addLogToState(newState, `${playerName} decide não usar o Selo.`);
                newState.seal_decision = { active: false, player: null, king_player: null };
                await processDomainCapture(kingPlayerNumber, newState);
            }

            async function sendChatMessage() {
                const chatInput = document.getElementById('chat-input');
                const messageText = chatInput.value.trim();
                if (!messageText) return;

                const senderName = localPlayerId === 'player1' ? localGameState.player1.name : localGameState.player2.name;
                const newMessage = { sender: senderName, senderId: localPlayerId, text: messageText, timestamp: new Date().toISOString() };
                
                let newState = JSON.parse(JSON.stringify(localGameState));
                if (!newState.chat) newState.chat = [];
                newState.chat.push(newMessage);
                if (newState.chat.length > 50) newState.chat.shift();
                await updateFirestore(newState);
                chatInput.value = '';
                chatInput.focus();
            }

            document.getElementById('create-game-btn').addEventListener('click', async () => {
                const playerName = document.getElementById('player-name-input').value.trim();
                if (!playerName) {
                    showCustomAlert("Por favor, digite seu nome para criar um jogo.");
                    return;
                }
            
                const newGameId = "game-" + Math.random().toString(36).substr(2, 9);
                gameId = newGameId;
                localPlayerId = 'player1';
                const demonDeck = demons.map(d => ({ ...d, Tipo: 'Demonio' }));
                const metalDeck = metals.map(m => ({ ...m, Tipo: 'Metal' }));
                const sealDeck = seals.map(s => ({ ...s, Tipo: 'Lendário' }));
                const fullDeck = [...demonDeck, ...metalDeck, ...sealDeck];
                let shuffledDeck = [...fullDeck].sort(() => Math.random() - 0.5);
                let shuffledProphecies = [...allProphecies].sort(() => Math.random() - 0.5);

                let newGameState = {
                    deck: shuffledDeck, discard_pile: [], play_history: [], removed_from_game: [], log: [], chat: [],
                    player1: { name: playerName, hand: [], prophecies: [], domains_captured: 0, uid: auth.currentUser?.uid || null },
                    player2: { name: 'Aguardando...', hand: [], prophecies: [], domains_captured: 0, uid: null },
                    current_player: 1, turn_count: 1, game_over: false, winner: null, status: 'waiting',
                    win_reason: null,
                    seal_decision: { active: false, player: null, king_player: null },
                    prophecy_choice: { active: false, player: null, choices: [], domain_owner: null, votes: {player1: null, player2: null} },
                    gameMode: selectedGameMode
                };
                
                if (selectedGameMode === 'cooperative') {
                    newGameState.sharedProphecies = shuffledProphecies.slice(0, 5).map(p => ({id: p.id, completed: false}));
                    newGameState.player1.prophecies = []; // Clear individual prophecies
                    newGameState.player2.prophecies = [];
                } else {
                    newGameState.player1.prophecies = shuffledProphecies.slice(0, 3).map(p => ({id: p.id, completed: false}));
                    newGameState.player2.prophecies = shuffledProphecies.slice(3, 6).map(p => ({id: p.id, completed: false}));
                }

                for (let i = 0; i < 7; i++) {
                    if(newGameState.deck.length > 0) newGameState.player1.hand.push(newGameState.deck.pop());
                    if(newGameState.deck.length > 0) newGameState.player2.hand.push(newGameState.deck.pop());
                }
                await setDoc(doc(db, gamesCollectionPath, gameId), newGameState);
                document.getElementById('game-id-display').textContent = gameId;
                document.getElementById('game-id-section').classList.remove('hidden');
                document.getElementById('create-game-btn').disabled = true;
                listenToGameChanges(gameId);
            });

            document.getElementById('join-game-btn').addEventListener('click', async () => {
                const joinId = document.getElementById('join-game-input').value.trim();
                const playerName = document.getElementById('player-name-input').value.trim();
                if (!joinId) {
                    showCustomAlert("Por favor, cole o ID do jogo.");
                    return;
                }
                if (!playerName) {
                    showCustomAlert("Por favor, digite seu nome para entrar em um jogo.");
                    return;
                }

                const gameRef = doc(db, gamesCollectionPath, joinId);
                const gameSnap = await getDoc(gameRef);
                if (gameSnap.exists() && !gameSnap.data().player2.uid) {
                    gameId = joinId;
                    localPlayerId = 'player2';
                    let gameData = gameSnap.data();
                    gameData.player2.uid = auth.currentUser?.uid || null;
                    gameData.player2.name = playerName;
                    gameData.status = 'active';
                                        
                    addLogToState(gameData, `${playerName} entrou. O jogo começou! É a vez de ${gameData.player1.name}.`);
                    await setDoc(gameRef, gameData);
                    listenToGameChanges(gameId);
                } else {
                    showCustomAlert("Jogo não encontrado ou já está cheio.");
                }
            });
            
            async function handleConfirmProphecyChoice() {
                const selectedRadio = document.querySelector('input[name="prophecy-selection"]:checked');
                if (!selectedRadio) {
                    showCustomAlert("Por favor, selecione uma opção.");
                    return;
                }
                const chosenId = selectedRadio.value;
                let newState = JSON.parse(JSON.stringify(localGameState));

                if (newState.gameMode === 'cooperative') {
                    newState.prophecy_choice.votes[localPlayerId] = chosenId;
                    const { votes, domain_owner } = newState.prophecy_choice;

                    // Check if both have voted
                    if (votes.player1 && votes.player2) {
                        let finalChoiceId;
                        if (votes.player1 === votes.player2) {
                            finalChoiceId = votes.player1;
                            addLogToState(newState, `Ambos os jogadores votaram em ${getProphecyDetails(finalChoiceId).Nome}.`);
                        } else {
                            // Tie-breaker
                            const tieChoices = [votes.player1, votes.player2];
                            finalChoiceId = tieChoices[Math.floor(Math.random() * 2)];
                            addLogToState(newState, `Votação empatada! O destino escolheu ${getProphecyDetails(finalChoiceId).Nome}.`);
                        }
                        const prophecy = newState.sharedProphecies.find(p => p.id === finalChoiceId);
                        if (prophecy) {
                            prophecy.completed = true;
                            addLogToState(newState, `Profecia cumprida: ${getProphecyDetails(finalChoiceId).Nome}!`);
                        }
                        
                        newState.prophecy_choice = { active: false, player: null, choices: [], domain_owner: null, votes: {player1: null, player2: null} };
                        if (checkWinCondition(newState)) {
                            await updateFirestore(newState);
                            return;
                        }
                        advanceTurn(domain_owner, newState);
                    }
                    await updateFirestore(newState);

                } else { // Competitive Mode
                    const playerNumber = newState.prophecy_choice.player;
                    const domainOwner = newState.prophecy_choice.domain_owner;
                    const playerName = getPlayerName(playerNumber, newState);
                    const prophecy = newState[`player${playerNumber}`].prophecies.find(p => p.id === chosenId);
                    if (prophecy) {
                        prophecy.completed = true;
                        addLogToState(newState, `${playerName} cumpriu: ${getProphecyDetails(chosenId).Nome}!`);
                    }
                    newState.prophecy_choice = { active: false, player: null, choices: [], domain_owner: null, votes: {player1: null, player2: null} };
                    if (checkWinCondition(newState)) {
                        await updateFirestore(newState);
                        return;
                    }
                    advanceTurn(domainOwner, newState);
                    await updateFirestore(newState);
                }
            }

            document.getElementById('confirm-prophecy-btn').addEventListener('click', handleConfirmProphecyChoice);

            function listenToGameChanges(id) {
                if (unsubscribe) unsubscribe();
                unsubscribe = onSnapshot(doc(db, gamesCollectionPath, id), (doc) => {
                    if (doc.exists()) {
                        localGameState = doc.data();
                        if (localGameState.status === 'active') {
                            document.getElementById('lobby').classList.add('hidden');
                            document.getElementById('game-board').classList.remove('hidden');
                        }
                        updateUI();
                    } else {
                        if (!localGameState.game_over) {
                            showCustomAlert("O jogo foi encerrado.");
                            setTimeout(() => window.location.reload(), 2000);
                        }
                    }
                });
            }

            document.getElementById('confirm-seal-btn').addEventListener('click', () => {
                if (localGameState.seal_decision?.active) {
                    handleSelo(localGameState.seal_decision.player);
                }
            });

            document.getElementById('decline-seal-btn').addEventListener('click', () => {
                if (localGameState.seal_decision?.active) {
                    handleDeclineSelo(localGameState.seal_decision.player);
                }
            });

            document.getElementById('send-chat-btn').addEventListener('click', sendChatMessage);
            document.getElementById('chat-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    sendChatMessage();
                }
            });

            // Game Mode Selection Listeners
            const compBtn = document.getElementById('mode-competitive-btn');
            const coopBtn = document.getElementById('mode-cooperative-btn');
            compBtn.addEventListener('click', () => {
                selectedGameMode = 'competitive';
                compBtn.classList.add('active');
                coopBtn.classList.remove('active');
            });
            coopBtn.addEventListener('click', () => {
                selectedGameMode = 'cooperative';
                coopBtn.classList.add('active');
                compBtn.classList.remove('active');
            });

            window.addEventListener('beforeunload', () => {
                if (gameId && localPlayerId === 'player1' && !localGameState.game_over) {
                    deleteDoc(doc(db, gamesCollectionPath, gameId));
                }
            });
        });
    </script>
</body>
</html>

