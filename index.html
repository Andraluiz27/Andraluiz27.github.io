<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goetia</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos gerais para uma aparência sombria e temática */
        body { font-family: 'Times New Roman', serif; background-color: #1a1a1a; color: #d1d1d1; }
        
        /* Estilo dos botões de carta para parecerem artefatos antigos */
        .card-button { border: 1px solid #4a4a4a; background-color: #2a2a2a; color: #c0c0c0; padding: 8px 12px; margin: 4px; border-radius: 6px; cursor: pointer; text-align: left; transition: all 0.2s ease-in-out; box-shadow: 0 2px 4px rgba(0,0,0,0.5); font-size: 0.9rem; }
        .card-button:hover:not(:disabled) { background-color: #3a3a3a; border-color: #888; transform: translateY(-2px); }
        .card-button:disabled { cursor: not-allowed; opacity: 0.5; }
        
        /* Destaque visual para cartas sendo sacrificadas */
        .sacrificing { border-color: #ef4444 !important; box-shadow: 0 0 8px #ef4444; }
        
        /* Elementos principais do tabuleiro de jogo */
        .game-board-element { border: 2px solid #5a3a1a; background-color: #3a2a1a; }
        
        /* Estilização da lista de profecias com tooltips informativos */
        .prophecy-list li { font-size: 0.9rem; margin-bottom: 4px; cursor: help; position: relative; }
        .prophecy-list li .tooltip { visibility: hidden; width: 250px; background-color: #333; color: #fff; text-align: center; border-radius: 6px; padding: 5px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -125px; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
        .prophecy-list li:hover .tooltip { visibility: visible; opacity: 1; }
        .prophecy-completed { text-decoration: line-through; color: #4ade80; }
        
        /* Efeito de transição para o indicador de turno */
        .turn-indicator { transition: all 0.3s ease; }
        
        /* Aparência das cartas do oponente (ocultas) */
        .opponent-card { background-color: #1e1e1e; border: 1px dashed #4a4a4a; color: #666; }
        
        /* Permite que o ID do jogo seja selecionado para cópia */
        #game-id-display { user-select: all; }
        
        /* Estilos para o modal de escolha de profecia */
        .prophecy-choice-label { display: block; padding: 12px; border: 1px solid #4a4a4a; border-radius: 6px; background-color: #2a2a2a; cursor: pointer; transition: background-color 0.2s; }
        .prophecy-choice-label:hover { background-color: #3a3a3a; }
        input[type="radio"]:checked + .prophecy-choice-label { background-color: #4c1d95; border-color: #8b5cf6; }
        input[type="radio"] { opacity: 0; position: fixed; width: 0; }
        
        /* Estilo para as cartas no tabuleiro de domínio */
        .domain-card-item { background-color: #2a2a2a; color: #c0c0c0; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; border: 1px solid #4a4a4a; }
        
        /* Estilos para as áreas de Log e Chat */
        .log-area, .chat-area { background-color: #1f1f1f; border: 1px solid #4a4a4a; height: 180px; overflow-y: auto; padding: 10px; font-family: monospace; font-size: 0.85rem; }
        .log-area { display: flex; flex-direction: column-reverse; /* Mensagens mais recentes no topo */ }
        .log-area strong { color: #f59e0b; }
        
        /* Estilos das mensagens de chat para diferenciar os jogadores */
        .chat-area { display: flex; flex-direction: column; }
        .chat-message { padding: 6px 10px; border-radius: 12px; margin-bottom: 6px; max-width: 85%; word-wrap: break-word; }
        .chat-message.player1 { background-color: #1e40af; color: #eff6ff; align-self: flex-start; border-bottom-left-radius: 2px; }
        .chat-message.player2 { background-color: #15803d; color: #f0fdf4; align-self: flex-end; border-bottom-right-radius: 2px; }
        .chat-message .sender { font-weight: bold; font-size: 0.75rem; display: block; margin-bottom: 2px; opacity: 0.9; }

        /* Estilos para a seleção de modo de jogo */
        .game-mode-selector { display: flex; justify-content: center; gap: 1rem; margin-bottom: 1.5rem; }
        .mode-btn { padding: 10px 20px; border: 2px solid #4a4a4a; background-color: #2a2a2a; color: #c0c0c0; font-weight: bold; border-radius: 8px; cursor: pointer; transition: all 0.2s; }
        .mode-btn.active { background-color: #a16207; border-color: #f59e0b; color: white; }
    </style>
</head>
<body class="p-4 md:p-8">

    <div id="game-container" class="max-w-7xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-4xl font-bold text-amber-200">Goetia</h1>
            <p class="text-lg text-gray-400">Protótipo Online</p>
        </header>

        <!-- Seção do Lobby: onde os jogadores criam ou entram em um jogo -->
        <main id="lobby" class="text-center bg-gray-900 p-8 rounded-lg max-w-lg mx-auto">
             <h2 class="text-2xl font-bold text-amber-300 mb-4">Modo de Jogo</h2>
             <div class="game-mode-selector">
                <button id="mode-competitive-btn" class="mode-btn active">Competitivo</button>
                <button id="mode-cooperative-btn" class="mode-btn">Cooperativo</button>
             </div>
             <hr class="border-gray-700 my-6">
             <h2 class="text-2xl font-bold text-amber-300 mb-4">Sala de Jogo</h2>
             <button id="create-game-btn" class="w-full mb-4 px-6 py-2 bg-amber-700 hover:bg-amber-600 text-white font-bold rounded-lg shadow-lg transition-colors">Criar Novo Jogo</button>
             <div id="game-id-section" class="hidden mb-4">
                 <p class="text-gray-300">Compartilhe este ID com seu oponente:</p>
                 <div class="flex items-center justify-center mt-2">
                     <p id="game-id-display" class="bg-gray-800 text-amber-200 font-mono p-2 rounded-l"></p>
                     <button id="copy-id-btn" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white font-bold rounded-r transition-colors">Copiar</button>
                 </div>
                 <p id="copy-feedback" class="text-green-400 text-sm mt-2 h-4"></p>
             </div>
             <hr class="border-gray-700 my-6">
             <input type="text" id="join-game-input" placeholder="Cole o ID do Jogo aqui" class="w-full bg-gray-800 border border-gray-600 text-white p-2 rounded mb-4">
             <button id="join-game-btn" class="w-full px-6 py-2 bg-blue-700 hover:bg-blue-600 text-white font-bold rounded-lg shadow-lg transition-colors">Entrar no Jogo</button>
        </main>

        <!-- Tabuleiro Principal do Jogo -->
        <section id="game-board" class="hidden">
            <!-- Informações Gerais do Jogo: Grimório, Turno, Descarte -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                <div class="flex flex-col items-center justify-center game-board-element p-4 rounded-lg">
                    <h3 class="text-xl font-bold text-amber-300 mb-2">Grimório</h3>
                    <p id="deck-count" class="text-2xl font-mono">0</p>
                </div>
                <div id="turn-display" class="flex flex-col items-center justify-center bg-gray-800 p-4 rounded-lg">
                     <h2 id="turn-indicator" class="text-2xl font-bold text-center text-amber-400">Turno 1</h2>
                     <p id="player-turn" class="text-gray-300">Aguardando...</p>
                </div>
                <div class="flex flex-col items-center justify-center game-board-element p-4 rounded-lg">
                    <h3 class="text-xl font-bold text-amber-300 mb-2">Monte de Descarte</h3>
                    <div id="discard-pile-card" class="card-button text-center min-h-[50px] flex items-center justify-center"></div>
                </div>
            </div>

            <!-- Tabuleiro de Profecias (Modo Cooperativo) -->
            <div id="coop-board-container" class="hidden bg-gray-800 p-4 rounded-lg mb-6">
                <h3 class="text-xl font-bold text-center text-amber-300 mb-2">Profecias Compartilhadas</h3>
                <p class="text-center text-lg mb-4">Progresso: <span id="coop-prophecy-progress" class="font-bold text-green-400">0 / 5</span></p>
                <ul id="coop-prophecies" class="flex flex-wrap justify-center gap-2 list-none"></ul>
            </div>
            
            <!-- Tabuleiro de Domínio Atual -->
            <div id="domain-board-container" class="bg-gray-800 p-4 rounded-lg mb-6">
                <h3 class="text-xl font-bold text-center text-amber-300 mb-2">Domínio Atual</h3>
                <div id="domain-board-cards" class="flex flex-wrap justify-center gap-2 min-h-[30px]"></div>
            </div>

            <!-- Áreas dos Jogadores -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <!-- Área do Jogador 1 -->
                <div id="player1-area" class="bg-gray-900 p-6 rounded-lg border-2 border-transparent turn-indicator">
                    <h2 class="text-2xl font-bold mb-3 text-blue-300">Jogador 1</h2>
                    <div id="player1-hand" class="mb-4 min-h-[100px] flex flex-wrap gap-2"></div>
                    <div id="player1-prophecy-area" class="bg-gray-800 p-3 rounded">
                        <h4 class="font-bold mb-2 text-blue-200">Profecias Secretas:</h4>
                        <ul id="player1-prophecies" class="list-disc list-inside prophecy-list"></ul>
                    </div>
                     <div class="mt-4">
                         <h4 class="font-bold text-blue-200">Domínios Capturados: <span id="player1-dominions">0</span></h4>
                     </div>
                </div>
                <!-- Área do Jogador 2 -->
                <div id="player2-area" class="bg-gray-900 p-6 rounded-lg border-2 border-transparent turn-indicator">
                    <h2 class="text-2xl font-bold mb-3 text-green-300">Jogador 2</h2>
                    <div id="player2-hand" class="mb-4 min-h-[100px] flex flex-wrap gap-2"></div>
                    <div id="player2-prophecy-area" class="bg-gray-800 p-3 rounded">
                        <h4 class="font-bold mb-2 text-green-200">Profecias Secretas:</h4>
                        <ul id="player2-prophecies" class="list-disc list-inside prophecy-list"></ul>
                    </div>
                     <div class="mt-4">
                         <h4 class="font-bold text-green-200">Domínios Capturados: <span id="player2-dominions">0</span></h4>
                     </div>
                </div>
            </div>

            <!-- Container para Log e Chat -->
            <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Área de Log -->
                <div>
                    <h3 class="text-xl font-bold mb-2 text-amber-300">Log da Partida</h3>
                    <div id="log-area" class="log-area rounded-lg"></div>
                </div>
                <!-- Área de Chat -->
                <div>
                    <h3 class="text-xl font-bold mb-2 text-amber-300">Chat</h3>
                    <div id="chat-area" class="chat-area rounded-t-lg"></div>
                    <div class="flex">
                        <input type="text" id="chat-input" placeholder="Digite sua mensagem..." class="flex-grow bg-gray-800 border border-gray-600 text-white p-2 focus:outline-none focus:border-amber-500 rounded-bl-lg">
                        <button id="send-chat-btn" class="px-4 py-2 bg-amber-700 hover:bg-amber-600 text-white font-bold rounded-br-lg">Enviar</button>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Modais que aparecem sobre o jogo -->
        <!-- Modal de Fim de Jogo -->
        <div id="end-game-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-gray-900 p-8 rounded-lg shadow-2xl text-center border-2 border-amber-500">
                <h2 id="winner-text" class="text-3xl font-bold text-amber-300 mb-4"></h2>
                <p id="win-reason-text" class="text-gray-300 mb-6"></p>
                <button onclick="window.location.reload()" class="px-6 py-2 bg-amber-700 hover:bg-amber-600 text-white font-bold rounded-lg">Jogar Novamente</button>
            </div>
        </div>

        <!-- Modal de Decisão do Selo -->
        <div id="seal-decision-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-gray-800 p-8 rounded-lg shadow-2xl text-center border-2 border-yellow-500">
                <h2 class="text-2xl font-bold text-yellow-300 mb-4">Oponente jogou um Rei!</h2>
                <p id="seal-modal-text" class="text-gray-300 mb-6">Você deseja usar o seu Selo de Salomão para roubar este Domínio?</p>
                <div class="flex justify-center space-x-4">
                    <button id="confirm-seal-btn" class="px-6 py-2 bg-green-600 hover:bg-green-500 text-white font-bold rounded-lg">Sim, Usar Selo</button>
                    <button id="decline-seal-btn" class="px-6 py-2 bg-red-700 hover:bg-red-600 text-white font-bold rounded-lg">Não, Passar</button>
                </div>
            </div>
        </div>

        <!-- Modal de Escolha de Profecia -->
        <div id="prophecy-choice-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-gray-800 p-8 rounded-lg shadow-2xl text-center border-2 border-purple-500 max-w-lg">
                <h2 id="prophecy-modal-title" class="text-2xl font-bold text-purple-300 mb-4">Múltiplas Profecias Cumpridas!</h2>
                <p id="prophecy-modal-text" class="text-gray-300 mb-6">Escolha qual profecia deseja registrar:</p>
                <div id="prophecy-options" class="space-y-3 mb-6 text-left"></div>
                <p id="prophecy-vote-status" class="text-gray-400 text-sm mb-4 hidden"></p>
                <button id="confirm-prophecy-btn" class="px-6 py-2 bg-purple-600 hover:bg-purple-500 text-white font-bold rounded-lg w-full">Confirmar</button>
            </div>
        </div>
    </div>
        
<script type="module">
    // Importações do Firebase SDK
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getFirestore, doc, getDoc, setDoc, onSnapshot, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    
    // =================================================================================
    // CONFIGURAÇÃO INICIAL E DADOS DO JOGO
    // =================================================================================
    
    // Dados de todas as cartas do jogo
    const demons = [ {Nome:"Bael", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Riqueza"}, {Nome:"Paimon", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Conhecimento"}, {Nome:"Beleth", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Riqueza"}, {Nome:"Purson", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Conhecimento"}, {Nome:"Asmoday", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Guerra"}, {Nome:"Vine", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Guerra"}, {Nome:"Balam", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Conhecimento"}, {Nome:"Zagan", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Riqueza"}, {Nome:"Belial", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Riqueza"}, {Nome:"Vassago", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Conhecimento"}, {Nome:"Ipos", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Conhecimento"}, {Nome:"Stolas", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Guerra"}, {Nome:"Orobas", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Guerra"}, {Nome:"Agares", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Conhecimento"}, {Nome:"Valefor", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"}, {Nome:"Barbatos", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"}, {Nome:"Bathin", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Guerra"}, {Nome:"Saleos", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"}, {Nome:"Berith", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"}, {Nome:"Astaroth", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Conhecimento"}, {Nome:"Vepar", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Guerra"}, {Nome:"Vual", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"}, {Nome:"Murmur", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Conhecimento"}, {Nome:"Gremory", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"}, {Nome:"Haures", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Guerra"}, {Nome:"Amduscias", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Guerra"}, {Nome:"Dantalion", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"}, {Nome:"Aim", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Guerra"}, {Nome:"Amon", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Riqueza"}, {Nome:"Naberius", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Conhecimento"}, {Nome:"Forneus", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Riqueza"}, {Nome:"Phenex", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Conhecimento"}, {Nome:"Orias", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Conhecimento"}, {Nome:"Andras", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Guerra"}, {Nome:"Andrealphus", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Conhecimento"}, {Nome:"Cimeies", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Guerra"}, {Nome:"Decarabia", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Guerra"}, {Nome:"Botis", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Riqueza"}, {Nome:"Glasya-Labolas", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Conhecimento"}, {Nome:"Ronove", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Guerra"}, {Nome:"Furfur", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Guerra"}, {Nome:"Halphas", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Guerra"}, {Nome:"Andromalius", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Riqueza"}, {Nome:"Furcas", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Conhecimento"}, {Nome:"Leraje", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Guerra"}, {Nome:"Foras", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Riqueza"}, {Nome:"Gaap", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Conhecimento"}, {Nome:"Malphas", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Guerra"}, {Nome:"Ose", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Conhecimento"}, {Nome:"Amy", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Riqueza"}, {Nome:"Valac", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Riqueza"} ];
    const metals = [...Array(4).fill({Nome: "Cobre", Título: "Duque"}), ...Array(5).fill({Nome: "Prata", Título: "Marquês"}), ...Array(4).fill({Nome: "Mercúrio", Título: "Presidente"}), ...Array(5).fill({Nome: "Estanho", Título: "Conde"})];
    const seals = Array(2).fill({Nome: "Selo de Salomão"});
    
    // Dados de todas as profecias do jogo
    const allProphecies = [ { id: 'p1', Nome: 'A Ascensão do Metal', Desc: 'Capture um Domínio que contenha apenas cartas de Metal (exceto o Rei).', check: (domain) => domain.slice(0, -1).every(card => card.Tipo === 'Metal'), coop_alt: { Desc: 'Capture um Domínio contendo 4 ou mais cartas de Metal.' , check: (domain) => domain.filter(c => c.Tipo === 'Metal').length >= 4 } }, { id: 'p2', Nome: 'A Trindade de Guerra', Desc: 'Capture um Domínio com exatamente 3 demônios da afinidade de Guerra.', check: (domain) => domain.filter(card => card.Afinidade === 'Guerra').length === 3 }, { id: 'p3', Nome: 'O Pacto Silencioso', Desc: 'Capture um Domínio com menos de 5 cartas no total.', check: (domain) => domain.length < 5 }, { id: 'p4', Nome: 'A Legião Completa', Desc: 'Capture um Domínio com 10 ou more cartas.', check: (domain) => domain.length >= 10 }, { id: 'p5', Nome: 'A Corte Infernal', Desc: 'Capture um Domínio que contenha um Duque, Marquês, Conde e Presidente.', check: (domain) => { const titles = new Set(domain.map(c => c.Título)); return ['Duque', 'Marquês', 'Conde', 'Presidente'].every(t => titles.has(t)); } }, { id: 'p6', Nome: 'O Tesouro de Prata', Desc: 'Capture um Domínio com 3 ou mais demônios de metal Prata.', check: (domain) => domain.filter(c => c.Metal === 'Prata').length >= 3 }, { id: 'p7', Nome: 'A Sabedoria Proibida', Desc: 'Capture um Domínio onde todas as cartas são da afinidade de Conhecimento.', check: (domain) => domain.slice(0, -1).every(card => card.Afinidade === 'Conhecimento') }, { id: 'p8', Nome: 'O Domínio do Sacrifício', Desc: 'Cumprida se você fizer um Sacrifício e o oponente capturar o Domínio no turno seguinte.', check: () => false, event: 'sacrifice_made' }, { id: 'p9', Nome: 'A Traição do Selo', Desc: 'Cumprida se seu oponente usar o Selo de Salomão em um Rei que você jogou.', check: () => false, event: 'selo_played' }, { id: 'p10', Nome: 'O Poder da Riqueza', Desc: 'Capture um Domínio onde o valor total de cartas de Riqueza é maior que 4.', check: (domain) => domain.filter(c => c.Afinidade === 'Riqueza').length > 4 }, { id: 'p11', Nome: 'A Ordem Hierárquica', Desc: 'Capture um Domínio onde as cartas foram jogadas em ordem hierárquica crescente (Presidente -> Conde -> Marquês -> Duque).', check: (domain) => { const titleHierarchy = { 'Presidente': 1, 'Conde': 2, 'Marquês': 3, 'Duque': 4 }; const ranks = domain.slice(0, -1).map(c => titleHierarchy[c.Título]).filter(Boolean); for(let i=0; i < ranks.length - 1; i++){ if(ranks[i] > ranks[i+1]) return false; } return true; } }, { id: 'p12', Nome: 'O Conclave de Cobre', Desc: 'Capture um Domínio contendo 3 ou mais Duques.', check: (domain) => domain.filter(c => c.Título === 'Duque').length >= 3 }, { id: 'p13', Nome: 'A Coroa Solitária', Desc: 'Capture um Domínio onde a única carta jogada é um Rei.', check: (domain) => domain.length === 1 && domain[0].Título === 'Rei' }, { id: 'p14', Nome: 'O Guardião do Conhecimento', Desc: 'Capture um Domínio onde a primeira e a última carta (antes do Rei) são da afinidade de Conhecimento.', check: (domain) => domain.length >= 2 && domain[0].Afinidade === 'Conhecimento' && domain[domain.length-2].Afinidade === 'Conhecimento' }, { id: 'p15', Nome: 'A Sombra de Mercúrio', Desc: 'Capture um Domínio que não contenha nenhum demônio, apenas metais.', check: (domain) => domain.slice(0,-1).every(c => c.Tipo === 'Metal') }, { id: 'p16', Nome: 'O Eco da Guerra', Desc: 'Capture um Domínio onde o número de cartas de Guerra é igual ao número de cartas de Riqueza (mínimo 2 de cada).', check: (domain) => { const warCount = domain.filter(c => c.Afinidade === 'Guerra').length; const wealthCount = domain.filter(c => c.Afinidade === 'Riqueza').length; return warCount >= 2 && warCount === wealthCount; } }, { id: 'p17', Nome: 'A Escala da Loucura', Desc: 'Cumprida se você jogar o 3º demônio consecutivo da mesma Afinidade.', check: () => false, event: 'affinity_streak' }, { id: 'p18', Nome: 'O Mestre dos Marionetes', Desc: 'Capture um Domínio onde o primeiro Duque foi jogado por um oponente.', check: (domain, player, history) => { const firstDukePlay = history.find(play => play.card.Título === 'Duque'); return firstDukePlay && firstDukePlay.player !== player; }, coop_alt: { Nome: 'Mestre dos Fantoches', Desc: 'Capture um Domínio onde a primeira carta e a última (antes do Rei) são Duques.', check: (domain) => { if (domain.length < 2) return false; const firstCard = domain[0]; const lastCardBeforeKing = domain[domain.length - 2]; return firstCard?.Título === 'Duque' && lastCardBeforeKing?.Título === 'Duque'; } } }, ];
    
    // Mapas para a lógica de hierarquia das cartas
    const titleHierarchy = { 'Presidente': 1, 'Conde': 2, 'Marquês': 3, 'Duque': 4 };
    const metalHierarchy = { 'Mercúrio': 1, 'Estanho': 2, 'Prata': 3, 'Cobre': 4 };

    // =================================================================================
    // ESTADO GLOBAL DO JOGO E VARIÁVEIS
    // =================================================================================

    let db, auth;
    let localGameState = {};
    let localPlayerId = null;
    let gameId = null;
    let unsubscribe = null; // Função para parar de ouvir as atualizações do Firestore
    let sacrificeSelection = [];
    let selectedGameMode = 'competitive';

    // =================================================================================
    // FUNÇÕES UTILITÁRIAS
    // =================================================================================

    // Retorna os detalhes de uma profecia, considerando o modo de jogo
    function getProphecyDetails(id, gameMode) {
        const prophecy = allProphecies.find(p => p.id === id);
        if (!prophecy) return null;
        return (gameMode === 'cooperative' && prophecy.coop_alt) 
            ? { ...prophecy, ...prophecy.coop_alt } 
            : prophecy;
    }

    // Formata os dados de uma carta para exibição
    function formatCardData(card) {
        if (!card) return { displayText: 'Monte Vazio' };
        let text = card.Nome;
        if (card.Tipo === 'Demonio') {
            text = `${card.Nome} (${card.Título}, ${card.Afinidade}${card.Metal ? ', ' + card.Metal : ''})`;
        } else if (card.Tipo === 'Metal') {
            text = `Metal: ${card.Nome}`;
        }
        return { ...card, displayText: text };
    }

    // Atualiza o estado do jogo no Firestore
    async function updateFirestore(newState) {
        if (gameId) {
            try {
                const gameRef = doc(db, `/artifacts/${__app_id}/public/data/ars_goetia_games`, gameId);
                await setDoc(gameRef, newState);
            } catch (e) {
                console.error("Erro ao escrever no Firestore: ", e);
                addLogToState(localGameState, "ERRO: Não foi possível sincronizar.");
                updateUI();
            }
        }
    }

    // Adiciona uma mensagem ao log do jogo
    function addLogToState(state, message, options) {
        if (!state.log) state.log = [];
        state.log.unshift({ text: message, type: options?.type || 'normal' });
        if (state.log.length > 30) state.log.pop();
    }

    // Exibe um alerta customizado na tela
    function showCustomAlert(message) {
        const alertBox = document.createElement('div');
        alertBox.className = 'fixed top-5 left-1/2 -translate-x-1/2 bg-red-800 text-white p-4 rounded-lg shadow-lg z-50';
        alertBox.textContent = message;
        document.body.appendChild(alertBox);
        setTimeout(() => alertBox.remove(), 3000);
    }

    // =================================================================================
    // LÓGICA PRINCIPAL DO JOGO
    // =================================================================================
    
    // Verifica se uma jogada é legal de acordo com as regras
    function isLegalMove(cardToPlay, topCard) {
        if (!topCard) return cardToPlay.Título !== 'Rei';
        if (cardToPlay.Tipo === 'Lendário') return false; // Selo de Salomão não pode ser jogado normalmente
        if (cardToPlay.Título === 'Rei') return true;

        if (cardToPlay.Tipo === 'Demonio' && topCard.Tipo === 'Demonio') {
            return (titleHierarchy[cardToPlay.Título] || 0) > (titleHierarchy[topCard.Título] || 0);
        }
        if (cardToPlay.Título && cardToPlay.Título === topCard.Título) return true;
        if (cardToPlay.Tipo === 'Demonio' && topCard.Tipo === 'Metal') {
            return cardToPlay.Metal && cardToPlay.Metal === topCard.Nome;
        }
        if (cardToPlay.Tipo === 'Metal' && topCard.Tipo === 'Metal') {
            return (metalHierarchy[cardToPlay.Nome] || 0) > (metalHierarchy[topCard.Nome] || 0);
        }
        return false;
    }

    // Verifica se profecias baseadas em eventos foram cumpridas
    function checkEventProphecies(eventName, playerNumber, state) {
        const playerId = `player${playerNumber}`;
        let fulfilled = false;
        state[playerId].prophecies.forEach(p => {
            const details = getProphecyDetails(p.id, state.gameMode);
            if (!p.completed && details?.event === eventName) {
                p.completed = true;
                fulfilled = true;
                addLogToState(state, `JOGADOR ${playerNumber} cumpriu a profecia: ${details.Nome}!`);
            }
        });
        if (fulfilled) checkWinCondition(state);
    }
    
    // Encontra profecias de domínio que podem ser cumpridas
    function findFulfillableDomainProphecies(playerNumber, domain, history, state) {
        const prophecyList = state.gameMode === 'cooperative' ? state.sharedProphecies : state[`player${playerNumber}`].prophecies;
        return prophecyList
            .filter(p => !p.completed)
            .map(p => getProphecyDetails(p.id, state.gameMode))
            .filter(details => details && !details.event && details.check(domain, playerNumber, history))
            .map(details => details.id);
    }

    // Verifica se a condição de vitória foi atingida
    function checkWinCondition(state) {
        if (state.game_over) return false;
        
        let winner = null;
        let reason = '';

        if (state.gameMode === 'cooperative') {
            if (state.sharedProphecies.filter(p => p.completed).length >= 5) {
                winner = 0; // 0 = vitória cooperativa
                reason = 'Ascensão Cooperativa';
            } else if (state.deck.length === 0 && state.current_player === 1) {
                winner = -1; // -1 = derrota cooperativa
                reason = 'Esgotamento';
            }
        } else { // Modo Competitivo
            const p1Score = state.player1.prophecies.filter(p => p.completed).length;
            const p2Score = state.player2.prophecies.filter(p => p.completed).length;
            if (p1Score >= 3) {
                winner = 1; reason = 'Ascensão';
            } else if (p2Score >= 3) {
                winner = 2; reason = 'Ascensão';
            } else if (state.deck.length === 0 && state.current_player === 1) {
                reason = 'Esgotamento';
                if (p1Score > p2Score) winner = 1;
                else if (p2Score > p1Score) winner = 2;
                else winner = 0; // Empate
            }
        }
        
        if(winner !== null) {
            state.game_over = true;
            state.winner = winner;
            state.win_reason = reason;
            return true;
        }
        return false;
    }

    // Avança para o próximo turno
    function advanceTurn(lastPlayer, state) {
        const playerWhoDraws = state.current_player;
        if (state.deck.length > 0) {
            state[`player${playerWhoDraws}`].hand.push(state.deck.pop());
            addLogToState(state, `JOGADOR ${playerWhoDraws} compra uma carta.`);
        } else {
            addLogToState(state, "Grimório vazio!");
        }
        state.turn_count++;
        state.current_player = lastPlayer === 1 ? 2 : 1;
        sacrificeSelection = []; // Limpa a seleção de sacrifício
    }

    // Processa a captura de um domínio
    async function processDomainCapture(playerNumber, state) {
        addLogToState(state, `JOGADOR ${playerNumber} captura um Domínio com ${state.discard_pile.length} cartas!`, { type: 'capture' });
        const capturedDomain = [...state.discard_pile];
        state.discard_pile = [];
        state.removed_from_game.push(...capturedDomain);
        state[`player${playerNumber}`].domains_captured++;
        
        const fulfillableProphecies = findFulfillableDomainProphecies(playerNumber, capturedDomain, state.play_history, state);
        
        if (state.gameMode === 'cooperative') {
            if (fulfillableProphecies.length > 0) {
                fulfillableProphecies.forEach(id => {
                    const prophecy = state.sharedProphecies.find(p => p.id === id);
                    if (prophecy && !prophecy.completed) {
                        prophecy.completed = true;
                        addLogToState(state, `Profecia Cooperativa Cumprida: ${getProphecyDetails(id, state.gameMode).Nome}!`);
                    }
                });
                if (checkWinCondition(state)) return await updateFirestore(state);
            }
            advanceTurn(playerNumber, state);
            await updateFirestore(state);

        } else { // Modo Competitivo
            if (fulfillableProphecies.length === 1) {
                const prophecy = state[`player${playerNumber}`].prophecies.find(p => p.id === fulfillableProphecies[0]);
                if (prophecy) {
                    prophecy.completed = true;
                    addLogToState(state, `Profecia cumprida: ${getProphecyDetails(prophecy.id, state.gameMode).Nome}!`);
                }
                if (checkWinCondition(state)) return await updateFirestore(state);
                advanceTurn(playerNumber, state);
                await updateFirestore(state);

            } else if (fulfillableProphecies.length > 1) {
                state.prophecy_choice = { active: true, player: playerNumber, choices: fulfillableProphecies, domain_owner: playerNumber, votes: { player1: null, player2: null } };
                addLogToState(state, `Múltiplas profecias cumpridas! Momento de decisão.`);
                await updateFirestore(state);

            } else {
                advanceTurn(playerNumber, state);
                await updateFirestore(state);
            }
        }
    }

    // =================================================================================
    // MANIPULAÇÃO DE EVENTOS (CLICKS, ENTRADAS)
    // =================================================================================

    // Lida com o clique em uma carta na mão do jogador
    async function handleCardClick(playerNumber, index) {
        const isMyTurn = localGameState.current_player === playerNumber && !localGameState.seal_decision?.active && !localGameState.prophecy_choice?.active;
        if (localGameState.game_over || !isMyTurn) return;

        const hand = localGameState[localPlayerId].hand;
        const topCard = localGameState.discard_pile.slice(-1)[0] || null;
        const hasLegalMoves = hand.some(card => isLegalMove(card, topCard));

        if (hasLegalMoves) {
            const cardToPlay = hand[index];
            if (isLegalMove(cardToPlay, topCard)) {
                await playCard(playerNumber, index, JSON.parse(JSON.stringify(localGameState)));
            } else {
                showCustomAlert("Jogada ilegal.");
            }
        } else {
            // Lógica de Sacrifício
            if (hand.length < 3) {
                let newState = JSON.parse(JSON.stringify(localGameState));
                const winner = localGameState.gameMode === 'cooperative' ? -1 : (playerNumber === 1 ? 2 : 1);
                addLogToState(newState, `JOGADOR ${playerNumber} não pode sacrificar e perde por Aniquilação!`);
                newState.game_over = true; newState.winner = winner; newState.win_reason = 'Aniquilação';
                await updateFirestore(newState);
                return;
            }
            
            addLogToState(localGameState, `Jogador ${playerNumber} não tem jogadas legais e precisa sacrificar 3 cartas.`);
            sacrificeSelection = sacrificeSelection.includes(index)
                ? sacrificeSelection.filter(i => i !== index)
                : [...sacrificeSelection, index];
            
            if (sacrificeSelection.length === 3) {
                await performSacrifice(playerNumber, JSON.parse(JSON.stringify(localGameState)));
            } else {
                updateUI();
            }
        }
    }
    
    // Executa a ação de Sacrifício
    async function performSacrifice(playerNumber, state) {
        addLogToState(state, `JOGADOR ${playerNumber} realiza um Sacrifício!`);
        const playerId = `player${playerNumber}`;
        const hand = state[playerId].hand;
        const cardToPlay = hand[sacrificeSelection[2]]; // A terceira carta selecionada é a que vai para o topo
        
        // Remove as cartas da mão em ordem decrescente de índice para evitar problemas
        sacrificeSelection.sort((a, b) => b - a).forEach(index => hand.splice(index, 1));
        
        state.discard_pile.push(cardToPlay);
        state.play_history.push({ player: playerNumber, card: cardToPlay });
        addLogToState(state, `JOGADOR ${playerNumber} joga (via Sacrifício): ${formatCardData(cardToPlay).displayText}`);
        sacrificeSelection = [];
        await handleEndOfTurn(playerNumber, cardToPlay, state);
    }
    
    // Executa a jogada de uma carta
    async function playCard(playerNumber, index, state) {
        const playerId = `player${playerNumber}`;
        const cardToPlay = state[playerId].hand.splice(index, 1)[0];
        state.discard_pile.push(cardToPlay);
        state.play_history.push({ player: playerNumber, card: cardToPlay });
        addLogToState(state, `JOGADOR ${playerNumber} joga: ${formatCardData(cardToPlay).displayText}`);
        
        // Verifica profecia de sequência de afinidade (somente competitivo)
        if (state.gameMode === 'competitive' && state.play_history.length >= 3 && cardToPlay.Tipo === 'Demonio') {
            const last3Plays = state.play_history.slice(-3);
            if (last3Plays.every(p => p.player === playerNumber && p.card.Tipo === 'Demonio' && p.card.Afinidade === cardToPlay.Afinidade)) {
                checkEventProphecies('affinity_streak', playerNumber, state);
            }
        }
        await handleEndOfTurn(playerNumber, cardToPlay, state);
    }

    // Lida com as ações de final de turno
    async function handleEndOfTurn(playerNumber, playedCard, state) {
        if (playedCard.Título === 'Rei') {
            state.seal_decision = { active: true, player: (playerNumber === 1 ? 2 : 1), king_player: playerNumber };
            await updateFirestore(state);
        } else {
            advanceTurn(playerNumber, state);
            if (!checkWinCondition(state)) {
                await updateFirestore(state);
            } else {
                await updateFirestore(state); // Salva o estado final de vitória/derrota
            }
        }
    }
    
    // Lida com a decisão de usar o Selo
    async function handleSelo(playerNumber) {
        if (localGameState.game_over) return;
        let newState = JSON.parse(JSON.stringify(localGameState));
        const seloIndex = newState[`player${playerNumber}`].hand.findIndex(c => c.Nome === 'Selo de Salomão');
        if (seloIndex === -1) return; // Segurança extra
        
        addLogToState(newState, `JOGADOR ${playerNumber} usa o Selo de Salomão!`);
        newState[`player${playerNumber}`].hand.splice(seloIndex, 1);
        newState.seal_decision = { active: false, player: null, king_player: null };
        await processDomainCapture(playerNumber, newState);
    }
    
    // Lida com a decisão de não usar o Selo
    async function handleDeclineSelo(decliningPlayerNumber) {
        let newState = JSON.parse(JSON.stringify(localGameState));
        const kingPlayerNumber = newState.seal_decision.king_player;
        addLogToState(newState, `Jogador ${decliningPlayerNumber} decide não usar o Selo.`);
        newState.seal_decision = { active: false, player: null, king_player: null };
        await processDomainCapture(kingPlayerNumber, newState);
    }
    
    // Envia uma mensagem no chat
    async function sendChatMessage() {
        const chatInput = document.getElementById('chat-input');
        const messageText = chatInput.value.trim();
        if (!messageText) return;

        const senderId = localPlayerId === 'player1' ? 1 : 2;
        const newMessage = { sender: `Jogador ${senderId}`, senderId: localPlayerId, text: messageText };
        
        let newState = JSON.parse(JSON.stringify(localGameState));
        if (!newState.chat) newState.chat = [];
        newState.chat.push(newMessage);
        if (newState.chat.length > 50) newState.chat.shift();
        
        await updateFirestore(newState);
        chatInput.value = '';
    }
    
    // Confirma a escolha de uma profecia
    async function handleConfirmProphecyChoice() {
        const selectedRadio = document.querySelector('input[name="prophecy-selection"]:checked');
        if (!selectedRadio) return showCustomAlert("Por favor, selecione uma opção.");

        const chosenId = selectedRadio.value;
        let newState = JSON.parse(JSON.stringify(localGameState));

        if (newState.gameMode === 'cooperative') {
            newState.prophecy_choice.votes[localPlayerId] = chosenId;
            const { votes, domain_owner } = newState.prophecy_choice;

            if (votes.player1 && votes.player2) { // Ambos votaram
                const finalChoiceId = (votes.player1 === votes.player2) 
                    ? votes.player1 
                    : [votes.player1, votes.player2][Math.floor(Math.random() * 2)]; // Desempate aleatório

                const prophecy = newState.sharedProphecies.find(p => p.id === finalChoiceId);
                if (prophecy) {
                    prophecy.completed = true;
                    addLogToState(newState, `Profecia cumprida: ${getProphecyDetails(finalChoiceId, newState.gameMode).Nome}!`);
                }
                
                newState.prophecy_choice = { active: false, player: null, choices: [], domain_owner: null, votes: {player1: null, player2: null} };
                if (checkWinCondition(newState)) return await updateFirestore(newState);
                advanceTurn(domain_owner, newState);
                await updateFirestore(newState);
            } else {
                await updateFirestore(newState); // Apenas salva o voto
            }
        } else { // Modo Competitivo
            const playerNumber = newState.prophecy_choice.player;
            const prophecy = newState[`player${playerNumber}`].prophecies.find(p => p.id === chosenId);
            if (prophecy) {
                prophecy.completed = true;
                addLogToState(newState, `JOGADOR ${playerNumber} cumpriu: ${getProphecyDetails(chosenId, newState.gameMode).Nome}!`);
            }
            newState.prophecy_choice = { active: false, player: null, choices: [], domain_owner: null, votes: {player1: null, player2: null} };
            if (checkWinCondition(newState)) return await updateFirestore(newState);
            advanceTurn(newState.prophecy_choice.domain_owner, newState);
            await updateFirestore(newState);
        }
    }

    // =================================================================================
    // ATUALIZAÇÃO DA INTERFACE DO USUÁRIO (UI)
    // =================================================================================
    
    function updateUI() {
        if (!localGameState.deck || !localPlayerId) return;

        const localPlayerNumber = localPlayerId === 'player1' ? 1 : 2;
        const isMyTurn = localGameState.current_player === localPlayerNumber && !localGameState.seal_decision?.active && !localGameState.prophecy_choice?.active;
        const isCoop = localGameState.gameMode === 'cooperative';
        
        // Atualiza a UI com base no modo de jogo
        document.getElementById('coop-board-container').classList.toggle('hidden', !isCoop);
        document.getElementById('player1-prophecy-area').classList.toggle('hidden', isCoop);
        document.getElementById('player2-prophecy-area').classList.toggle('hidden', isCoop);

        if (isCoop) {
            const completedCount = localGameState.sharedProphecies.filter(p => p.completed).length;
            document.getElementById('coop-prophecy-progress').textContent = `${completedCount} / 5`;
            const coopPropheciesContainer = document.getElementById('coop-prophecies');
            coopPropheciesContainer.innerHTML = localGameState.sharedProphecies.map(p => {
                const details = getProphecyDetails(p.id, localGameState.gameMode);
                return `<li class="p-2 rounded border ${p.completed ? 'bg-green-900 border-green-500 prophecy-completed' : 'bg-gray-700 border-gray-500'}">
                            <span class="font-bold">${details.Nome}</span>
                            <span class="tooltip">${details.Desc}</span>
                        </li>`;
            }).join('');
        }
        
        // Indicadores de jogador e turno
        document.getElementById('player1-area').querySelector('h2').textContent = `Jogador 1 ${localPlayerId === 'player1' ? '(Você)' : ''}`;
        document.getElementById('player2-area').querySelector('h2').textContent = `Jogador 2 ${localPlayerId === 'player2' ? '(Você)' : ''}`;
        document.getElementById('turn-indicator').textContent = `Turno ${localGameState.turn_count}`;
        document.getElementById('player-turn').textContent = isMyTurn ? "É A SUA VEZ!" : `Vez do Jogador ${localGameState.current_player}`;
        document.getElementById('player1-area').style.borderColor = localGameState.current_player === 1 ? '#f59e0b' : 'transparent';
        document.getElementById('player2-area').style.borderColor = localGameState.current_player === 2 ? '#f59e0b' : 'transparent';
        
        // Contagem de cartas e descarte
        document.getElementById('deck-count').textContent = localGameState.deck.length;
        const topCard = localGameState.discard_pile.slice(-1)[0] || null;
        document.getElementById('discard-pile-card').textContent = topCard ? formatCardData(topCard).displayText : 'Monte Vazio';
        
        // Log e Chat
        document.getElementById('log-area').innerHTML = (localGameState.log || []).map(entry => `<p>${entry.text.includes("captura um Domínio") ? `<strong>${entry.text}</strong>` : entry.text}</p>`).join('');
        const chatArea = document.getElementById('chat-area');
        chatArea.innerHTML = (localGameState.chat || []).map(msg => `<div class="chat-message ${msg.senderId}"><span class="sender">${msg.sender}</span>${msg.text}</div>`).join('');
        chatArea.scrollTop = chatArea.scrollHeight;
        
        // Cartas no domínio atual
        document.getElementById('domain-board-cards').innerHTML = localGameState.discard_pile.map(card => `<div class="domain-card-item">${formatCardData(card).displayText}</div>`).join('');
        
        // Mãos e profecias dos jogadores
        ['player1', 'player2'].forEach(pid => {
            const handContainer = document.getElementById(`${pid}-hand`);
            handContainer.innerHTML = ''; // Limpa antes de redesenhar
            if (localPlayerId === pid) {
                localGameState[pid].hand.forEach((card, index) => {
                    const btn = document.createElement('button');
                    btn.className = `card-button ${sacrificeSelection.includes(index) ? 'sacrificing' : ''}`;
                    btn.textContent = formatCardData(card).displayText;
                    btn.onclick = () => handleCardClick(localPlayerNumber, index);
                    btn.disabled = !isMyTurn;
                    handContainer.appendChild(btn);
                });
            } else {
                handContainer.innerHTML = Array(localGameState[pid].hand.length).fill('<div class="card-button opponent-card flex items-center justify-center">Oculta</div>').join('');
            }
            
            if (!isCoop) {
                document.getElementById(`${pid}-prophecies`).innerHTML = localGameState[pid].prophecies.map(p => {
                    const details = getProphecyDetails(p.id, localGameState.gameMode);
                    const text = (localPlayerId === pid) ? details.Nome : 'Profecia Oculta';
                    const tooltip = (localPlayerId === pid) ? `<span class="tooltip">${details.Desc}</span>` : '';
                    return `<li class="${p.completed ? 'prophecy-completed' : ''}">${text}${tooltip}</li>`;
                }).join('');
            }
            document.getElementById(`${pid}-dominions`).textContent = localGameState[pid].domains_captured;
        });

        // Lógica de exibição dos modais
        const sealModal = document.getElementById('seal-decision-modal');
        const amITheSealDecider = localGameState.seal_decision?.active && localGameState.seal_decision.player === localPlayerNumber;
        sealModal.classList.toggle('hidden', !amITheSealDecider);
        if (amITheSealDecider) {
            const hasSeal = localGameState[localPlayerId].hand.some(c => c.Nome === 'Selo de Salomão');
            document.getElementById('seal-modal-text').textContent = hasSeal ? 'Você deseja usar o seu Selo de Salomão?' : 'Você não possui o Selo de Salomão.';
            document.getElementById('confirm-seal-btn').classList.toggle('hidden', !hasSeal);
            document.getElementById('decline-seal-btn').textContent = hasSeal ? 'Não, Passar' : 'Continuar';
        }
        
        const prophecyModal = document.getElementById('prophecy-choice-modal');
        const amITheProphecyDecider = localGameState.prophecy_choice?.active && (isCoop || localGameState.prophecy_choice.player === localPlayerNumber);
        prophecyModal.classList.toggle('hidden', !amITheProphecyDecider);
        if (amITheProphecyDecider) {
            const optionsContainer = document.getElementById('prophecy-options');
            const voteStatus = document.getElementById('prophecy-vote-status');
            const choices = localGameState.prophecy_choice.choices;
            optionsContainer.innerHTML = choices.map((pId, index) => {
                const details = getProphecyDetails(pId, localGameState.gameMode);
                return `<div>
                            <input type="radio" id="prophecy-radio-${pId}" name="prophecy-selection" value="${pId}" ${index === 0 ? 'checked' : ''}>
                            <label for="prophecy-radio-${pId}" class="prophecy-choice-label">
                                <strong class="text-purple-300">${details.Nome}</strong><br>
                                <small class="text-gray-400">${details.Desc}</small>
                            </label>
                        </div>`;
            }).join('');
            
            if (isCoop) {
                document.getElementById('confirm-prophecy-btn').textContent = 'Votar';
                const myVote = localGameState.prophecy_choice.votes[localPlayerId];
                voteStatus.classList.toggle('hidden', !myVote);
                if(myVote) {
                    optionsContainer.querySelectorAll('input').forEach(r => r.disabled = true);
                    voteStatus.textContent = 'Você votou. Aguardando o outro jogador...';
                }
            }
        }

        if (localGameState.game_over) {
            endGameUI(localGameState.winner, localGameState.win_reason, localGameState.gameMode);
            if(unsubscribe) unsubscribe();
        }
    }
    
    // Mostra o modal de fim de jogo
    function endGameUI(winner, reason, gameMode) {
        const winnerText = document.getElementById('winner-text');
        const reasonText = document.getElementById('win-reason-text');
        winnerText.textContent = (gameMode === 'cooperative') 
            ? (winner === 0 ? "Vitória Cooperativa!" : "Derrota...") 
            : (winner === 0 ? "Empate!" : `Jogador ${winner} Venceu!`);
        reasonText.textContent = `Motivo: ${reason}`;
        document.getElementById('end-game-modal').classList.remove('hidden');
    }

    // =================================================================================
    // INICIALIZAÇÃO E LOBBY
    // =================================================================================

    // Inicializa o jogo quando o DOM estiver pronto
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            // Usa as variáveis de ambiente fornecidas pela plataforma
            const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            
            // Autentica o usuário
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Falha na inicialização ou autenticação:", error);
            document.body.innerHTML = `<div class="text-center text-red-500 p-8">Erro Crítico de Conexão.</div>`;
            return;
        }

        setupLobbyListeners();
    });

    // Configura os listeners de eventos do lobby
    function setupLobbyListeners() {
        // ... (código dos listeners para criar jogo, entrar, etc.)
        document.getElementById('create-game-btn').addEventListener('click', createNewGame);
        document.getElementById('join-game-btn').addEventListener('click', joinExistingGame);
        document.getElementById('confirm-prophecy-btn').addEventListener('click', handleConfirmProphecyChoice);
        document.getElementById('confirm-seal-btn').addEventListener('click', () => handleSelo(localGameState.seal_decision.player));
        document.getElementById('decline-seal-btn').addEventListener('click', () => handleDeclineSelo(localGameState.seal_decision.player));
        document.getElementById('send-chat-btn').addEventListener('click', sendChatMessage);
        document.getElementById('chat-input').addEventListener('keydown', (e) => { if (e.key === 'Enter') sendChatMessage(); });
        document.getElementById('copy-id-btn').addEventListener('click', copyGameId);
        
        // Listeners para seleção de modo de jogo
        const compBtn = document.getElementById('mode-competitive-btn');
        const coopBtn = document.getElementById('mode-cooperative-btn');
        compBtn.addEventListener('click', () => { selectedGameMode = 'competitive'; compBtn.classList.add('active'); coopBtn.classList.remove('active'); });
        coopBtn.addEventListener('click', () => { selectedGameMode = 'cooperative'; coopBtn.classList.add('active'); compBtn.classList.remove('active'); });

        window.addEventListener('beforeunload', () => {
            if (gameId && localPlayerId === 'player1' && !localGameState.game_over) {
                const gameRef = doc(db, `/artifacts/${__app_id}/public/data/ars_goetia_games`, gameId);
                deleteDoc(gameRef);
            }
        });
    }
    
    // Função para criar um novo jogo
    async function createNewGame() {
        gameId = "game-" + Math.random().toString(36).substr(2, 9);
        localPlayerId = 'player1';
        
        const fullDeck = [...demons.map(d => ({ ...d, Tipo: 'Demonio' })), ...metals.map(m => ({ ...m, Tipo: 'Metal' })), ...seals.map(s => ({ ...s, Tipo: 'Lendário' }))];
        let shuffledDeck = [...fullDeck].sort(() => Math.random() - 0.5);
        let shuffledProphecies = [...allProphecies].sort(() => Math.random() - 0.5);

        let newGameState = {
            deck: [], discard_pile: [], play_history: [], removed_from_game: [], log: [], chat: [],
            player1: { hand: [], prophecies: [], domains_captured: 0, uid: auth.currentUser?.uid },
            player2: { hand: [], prophecies: [], domains_captured: 0, uid: null },
            current_player: 1, turn_count: 1, game_over: false, winner: null, status: 'waiting',
            win_reason: '', gameMode: selectedGameMode,
            seal_decision: { active: false }, prophecy_choice: { active: false, votes: {player1: null, player2: null} },
        };
        
        // Distribui profecias com base no modo de jogo
        if (selectedGameMode === 'cooperative') {
            newGameState.sharedProphecies = shuffledProphecies.slice(0, 5).map(p => ({id: p.id, completed: false}));
        } else {
            newGameState.player1.prophecies = shuffledProphecies.slice(0, 3).map(p => ({id: p.id, completed: false}));
            newGameState.player2.prophecies = shuffledProphecies.slice(3, 6).map(p => ({id: p.id, completed: false}));
        }

        // Distribui as cartas iniciais
        for (let i = 0; i < 7; i++) {
            newGameState.player1.hand.push(shuffledDeck.pop());
            newGameState.player2.hand.push(shuffledDeck.pop());
        }
        newGameState.deck = shuffledDeck;

        const gameRef = doc(db, `/artifacts/${__app_id}/public/data/ars_goetia_games`, gameId);
        await setDoc(gameRef, newGameState);
        
        document.getElementById('game-id-display').textContent = gameId;
        document.getElementById('game-id-section').classList.remove('hidden');
        document.getElementById('create-game-btn').disabled = true;
        listenToGameChanges(gameId);
    }

    // Função para entrar em um jogo existente
    async function joinExistingGame() {
        const joinId = document.getElementById('join-game-input').value.trim();
        if (!joinId) return;
        const gameRef = doc(db, `/artifacts/${__app_id}/public/data/ars_goetia_games`, joinId);
        const gameSnap = await getDoc(gameRef);
        
        if (gameSnap.exists() && !gameSnap.data().player2.uid) {
            gameId = joinId;
            localPlayerId = 'player2';
            let gameData = gameSnap.data();
            gameData.player2.uid = auth.currentUser?.uid;
            gameData.status = 'active';
            addLogToState(gameData, "Jogador 2 entrou. O jogo começou! Vez do Jogador 1.");
            
            await setDoc(gameRef, gameData);
            listenToGameChanges(gameId);
        } else {
            showCustomAlert("Jogo não encontrado ou já está cheio.");
        }
    }
    
    // Função para copiar o ID do jogo
    function copyGameId() {
        const gameIdText = document.getElementById('game-id-display').textContent;
        // Usa um truque com um campo de texto temporário para copiar
        const tempInput = document.createElement('textarea');
        tempInput.value = gameIdText;
        document.body.appendChild(tempInput);
        tempInput.select();
        document.execCommand('copy');
        document.body.removeChild(tempInput);

        const feedback = document.getElementById('copy-feedback');
        feedback.textContent = 'ID Copiado!';
        setTimeout(() => feedback.textContent = '', 2000);
    }

    // Ouve as mudanças no estado do jogo no Firestore
    function listenToGameChanges(id) {
        if (unsubscribe) unsubscribe();
        const gameRef = doc(db, `/artifacts/${__app_id}/public/data/ars_goetia_games`, id);
        unsubscribe = onSnapshot(gameRef, (doc) => {
            if (doc.exists()) {
                localGameState = doc.data();
                if (localGameState.status === 'active') {
                    document.getElementById('lobby').classList.add('hidden');
                    document.getElementById('game-board').classList.remove('hidden');
                }
                updateUI();
            } else {
                if (!localGameState.game_over) {
                    showCustomAlert("O jogo foi encerrado pelo anfitrião.");
                    setTimeout(() => window.location.reload(), 2000);
                }
            }
        });
    }
</script>
</body>
</html>

