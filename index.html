<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Goetia</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/tsparticles-slim@2.12.0/tsparticles.slim.bundle.min.js"></script>
    <style>
    /* ----- FONTES PERSONALIZADAS ----- */
    @font-face {
        /* Fonte para Títulos */
        font-family: 'FonteDosTitulos'; 
        src: url('fonts/HellsCemetery-Regular.ttf') format('truetype');
    }

    @font-face {
        /* Fonte para Textos */
        font-family: 'FonteDosTextos'; 
        src: url('fonts/Remnant-Regular.ttf') format('truetype');
    }


    /* ----- APLICAÇÃO DAS FONTES ----- */
    body { 
        font-family: 'FonteDosTextos', 'Times New Roman', serif;
        background-color: #1a1a1a; 
        color: #d1d1d1; 
    }

    /* ADICIONE ESTE BLOCO ABAIXO */
    #game-container {
        position: relative;
        z-index: 1;
    }
    /* FIM DO BLOCO ADICIONADO */
    
    h1, h2, h3, h4 {
        font-family: 'FonteDosTitulos', 'Times New Roman', serif;
    }
    /* ----- ESTILOS DO JOGO ----- */
    #tsparticles {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1; /* Essencial para manter o efeito no fundo */
    }

    /* ----- ESTILOS DO JOGO ----- */
    .card-button { border: 1px solid #4a4a4a; background-color: #2a2a2a; color: #c0c0c0; padding: 8px 12px; margin: 4px; border-radius: 6px; cursor: pointer; text-align: left; transition: all 0.2s ease-in-out; box-shadow: 0 2px 4px rgba(0,0,0,0.5); font-size: 0.9rem; }
    .card-button:hover:not(:disabled) { background-color: #3a3a3a; border-color: #888; }
    .card-button:disabled { cursor: not-allowed; opacity: 0.5; }
    .sacrificing { border-color: #ef4444 !important; box-shadow: 0 0 8px #ef4444; }
    .game-board-element { border: 2px solid #5a3a1a; background-color: #3a2a1a; }
    .prophecy-list li { font-size: 0.85rem; margin-bottom: 4px; cursor: help; position: relative; }
    .prophecy-list li .tooltip { visibility: hidden; width: 250px; background-color: #333; color: #fff; text-align: center; border-radius: 6px; padding: 5px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -125px; opacity: 0; transition: opacity 0.3s; }
    .prophecy-list li:hover .tooltip { visibility: visible; opacity: 1; }
    .prophecy-completed { text-decoration: line-through; color: #4ade80; }
    .turn-indicator { transition: all 0.3s ease; }
    .opponent-card { background-color: #1e1e1e; border: 1px dashed #4a4a4a; color: #666; }
    #game-id-display { user-select: all; }
    .prophecy-choice-label { display: block; padding: 12px; border: 1px solid #4a4a4a; border-radius: 6px; background-color: #2a2a2a; cursor: pointer; transition: background-color 0.2s; }
    .prophecy-choice-label:hover { background-color: #3a3a3a; }
    input[type="radio"]:checked + .prophecy-choice-label { background-color: #4c1d95; border-color: #8b5cf6; }
    input[type="radio"] { opacity: 0; position: fixed; width: 0; }
    .domain-card-item { background-color: #2a2a2a; color: #c0c0c0; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; border: 1px solid #4a4a4a; }
    .log-area, .chat-area { background-color: #1f1f1f; border: 1px solid #4a4a4a; height: 180px; overflow-y: auto; padding: 10px; font-family: monospace; font-size: 0.85rem; }
    .log-area { display: flex; flex-direction: column-reverse; }
    .log-area strong { color: #f59e0b; }
    .chat-area { display: flex; flex-direction: column; }
    .chat-message { padding: 6px 10px; border-radius: 12px; margin-bottom: 6px; max-width: 85%; word-wrap: break-word; }
    .chat-message.player1 { background-color: #1e40af; color: #eff6ff; align-self: flex-start; border-bottom-left-radius: 2px; }
    .chat-message.player2 { background-color: #15803d; color: #f0fdf4; align-self: flex-end; border-bottom-right-radius: 2px; }
    .chat-message .sender { font-weight: bold; font-size: 0.75rem; display: block; margin-bottom: 2px; opacity: 0.9; }
    .game-mode-selector { display: flex; justify-content: center; gap: 1rem; margin-bottom: 1.5rem; }
    .mode-btn { padding: 10px 20px; border: 2px solid #4a4a4a; background-color: #2a2a2a; color: #c0c0c0; font-weight: bold; border-radius: 8px; cursor: pointer; transition: all 0.2s; }
    .mode-btn.active { background-color: #a16207; border-color: #f59e0b; color: white; }
    .coop-prophecy { position: relative; cursor: help; }
    .coop-prophecy .tooltip { visibility: hidden; width: 250px; background-color: #333; color: #fff; text-align: center; border-radius: 6px; padding: 5px; position: absolute; z-index: 10; bottom: 125%; left: 50%; margin-left: -125px; opacity: 0; transition: opacity 0.3s; text-decoration: none; }
    .coop-prophecy:hover:not(.prophecy-completed) .tooltip { visibility: visible; opacity: 1; }
    #help-icon { position: fixed; bottom: 20px; right: 20px; width: 40px; height: 40px; background-color: #4a4a4a; color: #d1d1d1; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; font-weight: bold; cursor: help; z-index: 1000; border: 2px solid #6a6a6a; user-select: none; }
    #help-icon .help-tooltip { visibility: hidden; opacity: 0; width: 300px; background-color: #1f1f1f; color: #d1d1d1; text-align: left; border-radius: 8px; padding: 12px; position: absolute; z-index: 1; bottom: 120%; right: 0;  transition: opacity 0.3s ease-in-out; border: 1px solid #5a5a5a; box-shadow: 0 4px 12px rgba(0,0,0,0.7); }
    #help-icon:hover .help-tooltip { visibility: visible; opacity: 1; }
    .help-tooltip .tooltip-section { margin-bottom: 10px; }
    .help-tooltip .tooltip-section:last-child { margin-bottom: 0; }
    .help-tooltip p, .help-tooltip ul { font-size: 0.85rem; color: #c0c0c0; }
    .help-tooltip strong { font-size: 0.70rem; }
    .prophecy-public-item { padding: 8px 12px; border-radius: 6px; border: 1px solid #6b7280; background-color: #374151; cursor: help; position: relative; }
    .prophecy-public-item .tooltip { visibility: hidden; width: 250px; background-color: #333; color: #fff; text-align: center; border-radius: 6px; padding: 5px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -125px; opacity: 0; transition: opacity 0.3s; }
    .prophecy-public-item:hover .tooltip { visibility: visible; opacity: 1; }
    .prophecy-completed-by-p1 { border-color: #60a5fa; background-color: #1e3a8a; color: #eff6ff; }
    .prophecy-completed-by-p2 { border-color: #4ade80; background-color: #166534; color: #f0fdf4; }
    </style>
</head>
<body class="p-4 md:p-8">

    <canvas id="tsparticles"></canvas>

    <div id="game-container" class="max-w-7xl mx-auto">
        <div class="text-center mb-6">
            <h1 class="text-7xl font-bold text-amber-300">Goetia</h1>
        </div>

        <div id="lobby" class="text-center bg-gray-900 p-8 rounded-lg max-w-lg mx-auto">
             <h2 class="text-3xl font-bold text-amber-300 mb-4">Modo de Jogo</h2>
             <div class="game-mode-selector">
                <button id="mode-competitive-btn" class="mode-btn active">Competitivo</button>
                <button id="mode-cooperative-btn" class="mode-btn">Cooperativo</button>
                <button id="mode-cpu-btn" class="mode-btn">VS CPU</button>
             </div>
             <hr class="border-gray-700 my-6">
              <h2 class="text-3xl font-bold text-amber-300 mb-4">Seu Nome</h2>
              <input type="text" id="player-name-input" placeholder="Digite seu nome aqui" class="w-full bg-gray-800 border border-gray-600 text-white p-2 rounded mb-6" maxlength="20">
             <div id="online-options">
                <h2 class="text-3xl font-bold text-amber-300 mb-4">Sala de Jogo</h2>
                <button id="create-game-btn" class="w-full mb-4 px-6 py-2 bg-amber-700 hover:bg-amber-600 text-white font-bold rounded-lg shadow-lg">Criar Novo Jogo</button>
                <div id="game-id-section" class="hidden mb-4">
                    <p class="text-gray-300">Compartilhe este ID com seu oponente:</p>
                    <p id="game-id-display" class="bg-gray-800 text-amber-200 font-mono p-2 rounded mt-2"></p>
                </div>
                <hr class="border-gray-700 my-6">
                <input type="text" id="join-game-input" placeholder="Cole o ID do Jogo aqui" class="w-full bg-gray-800 border border-gray-600 text-white p-2 rounded mb-4">
                <button id="join-game-btn" class="w-full px-6 py-2 bg-blue-700 hover:bg-blue-600 text-white font-bold rounded-lg shadow-lg">Entrar no Jogo</button>
             </div>
             <div id="cpu-options" class="hidden">
                <button id="start-cpu-game-btn" class="w-full px-6 py-2 bg-purple-700 hover:bg-purple-600 text-white font-bold rounded-lg shadow-lg">Iniciar Jogo vs CPU</button>
             </div>
        </div>

        <div id="game-board" class="hidden">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                <div class="flex flex-col items-center justify-center game-board-element p-4 rounded-lg">
                    <h3 class="text-xl font-bold text-amber-300 mb-2">Grimório</h3>
                    <p id="deck-count" class="text-2xl font-mono">0</p>
                </div>
                <div id="turn-display" class="flex flex-col items-center justify-center bg-gray-800 p-4 rounded-lg">
                     <h2 id="turn-indicator" class="text-2xl font-bold text-center text-amber-400">Turno 1</h2>
                     <p id="player-turn" class="text-gray-300">Aguardando Oponente...</p>
                </div>
                <div class="flex flex-col items-center justify-center game-board-element p-4 rounded-lg">
                    <h3 class="text-xl font-bold text-amber-300 mb-2">Domínio</h3>
                    <div id="discard-pile-card" class="card-button text-center min-h-[50px] flex items-center justify-center"></div>
                </div>
            </div>

            <div id="coop-board-container" class="hidden bg-gray-800 p-4 rounded-lg mb-6">
                <h3 class="text-xl font-bold text-center text-amber-300 mb-2">Profecias Compartilhadas</h3>
                <p class="text-center text-lg mb-4">Progresso: <span id="coop-prophecy-progress" class="font-bold text-green-400">0 / 7</span></p>
                <div id="coop-prophecies" class="flex flex-wrap justify-center gap-2"></div>
            </div>
            
            <div id="domain-board-container" class="bg-gray-800 p-4 rounded-lg mb-6">
                <h3 class="text-xl font-bold text-center text-amber-300 mb-2">Cartas no Domínio</h3>
                <div id="domain-board-cards" class="flex flex-wrap justify-center gap-2 min-h-[30px]"></div>
            </div>

            <div id="public-prophecy-container" class="hidden bg-gray-800 p-4 rounded-lg mb-6">
                <h3 class="text-xl font-bold text-center text-amber-300 mb-2">Profecias Públicas</h3>
                <div id="public-prophecies" class="flex flex-wrap justify-center gap-2 min-h-[30px]"></div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div id="player1-area" class="bg-gray-900 p-6 rounded-lg border-2 border-transparent turn-indicator">
                    <h2 class="text-2xl font-bold mb-3 text-blue-300">Jogador 1</h2>
                    <div id="player1-hand" class="mb-4 min-h-[100px] flex flex-wrap"></div>
                    <div id="player1-prophecy-area" class="bg-gray-800 p-3 rounded">
                        <h4 class="font-bold mb-2 text-blue-200">Profecias Secretas:</h4>
                        <ul id="player1-prophecies" class="list-disc list-inside prophecy-list"></ul>
                    </div>
                     <div class="mt-4">
                         <h4 class="font-bold text-blue-200">Domínios Capturados: <span id="player1-dominions">0</span></h4>
                     </div>
                </div>
                <div id="player2-area" class="bg-gray-900 p-6 rounded-lg border-2 border-transparent turn-indicator">
                    <h2 class="text-2xl font-bold mb-3 text-green-300">Jogador 2</h2>
                    <div id="player2-hand" class="mb-4 min-h-[100px] flex flex-wrap"></div>
                    <div id="player2-prophecy-area" class="bg-gray-800 p-3 rounded">
                        <h4 class="font-bold mb-2 text-green-200">Profecias Secretas:</h4>
                        <ul id="player2-prophecies" class="list-disc list-inside prophecy-list"></ul>
                    </div>
                     <div class="mt-4">
                         <h4 class="font-bold text-green-200">Domínios Capturados: <span id="player2-dominions">0</span></h4>
                     </div>
                </div>
            </div>

            <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <h3 class="text-xl font-bold mb-2 text-amber-300">Log da Partida</h3>
                    <div id="log-area" class="log-area rounded-lg"></div>
                </div>
                <div>
                    <h3 class="text-xl font-bold mb-2 text-amber-300">Chat</h3>
                    <div id="chat-area" class="chat-area rounded-t-lg"></div>
                    <div class="flex">
                        <input type="text" id="chat-input" placeholder="Digite sua mensagem..." class="text-sm flex-grow bg-gray-800 border border-gray-600 text-white p-2 focus:outline-none focus:border-amber-500 rounded-bl-lg">
                        <button id="send-chat-btn" class="px-4 py-2 bg-amber-700 hover:bg-amber-600 text-white font-bold rounded-br-lg">Enviar</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="end-game-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-gray-900 p-8 rounded-lg shadow-2xl text-center border-2 border-amber-500">
                <h2 id="winner-text" class="text-3xl font-bold text-amber-300 mb-4"></h2>
                <p id="win-reason-text" class="text-gray-300 mb-6"></p>
                <button onclick="window.location.reload()" class="px-6 py-2 bg-amber-700 hover:bg-amber-600 text-white font-bold rounded-lg">Jogar Novamente</button>
            </div>
        </div>

        <div id="seal-decision-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-gray-800 p-8 rounded-lg shadow-2xl text-center border-2 border-yellow-500">
                <h2 class="text-2xl font-bold text-yellow-300 mb-4">Oponente jogou um Rei!</h2>
                <p id="seal-modal-text" class="text-gray-300 mb-6">Você deseja usar o seu Selo de Salomão para roubar este Domínio?</p>
                <div class="flex justify-center space-x-4">
                    <button id="confirm-seal-btn" class="px-6 py-2 bg-green-600 hover:bg-green-500 text-white font-bold rounded-lg">Sim, Usar Selo</button>
                    <button id="decline-seal-btn" class="px-6 py-2 bg-red-700 hover:bg-red-600 text-white font-bold rounded-lg">Não, Passar</button>
                </div>
            </div>
        </div>

        <div id="prophecy-choice-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-gray-800 p-8 rounded-lg shadow-2xl text-center border-2 border-purple-500 max-w-lg">
                <h2 id="prophecy-modal-title" class="text-2xl font-bold text-purple-300 mb-4">Múltiplas Profecias Cumpridas!</h2>
                <p id="prophecy-modal-text" class="text-gray-300 mb-6">Escolha qual profecia deseja registrar:</p>
                <div id="prophecy-options" class="space-y-3 mb-6 text-left"></div>
                <p id="prophecy-vote-status" class="text-gray-400 text-sm mb-4 hidden"></p>
                <button id="confirm-prophecy-btn" class="px-6 py-2 bg-purple-600 hover:bg-purple-500 text-white font-bold rounded-lg w-full">Confirmar</button>
            </div>
        </div>
    </div>

    <div id="help-icon">
        ?
        <div class="help-tooltip">
            <h4 class="font-bold text-amber-300 mb-2 text-center">Hierarquias do Jogo</h4>
            
            <div class="tooltip-section">
                <strong>Hierarquia dos Títulos:</strong>
                <p>Presidente &lt; Conde &lt; Marquês &lt; Duque &lt; Rei</p>
            </div>

            <div class="tooltip-section">
                <strong>Hierarquia dos Metais:</strong>
                <p>Mercúrio &lt; Estanho &lt; Prata &lt; Cobre</p>
            </div>

            <div class="tooltip-section">
                <strong>Níveis de Hierarquia:</strong>
                <ul class="list-disc list-inside text-left">
                    <li><b>Baixa:</b> Presidente, Conde, Marquês</li>
                    <li><b>Média:</b> Duque</li>
                    <li><b>Alta:</b> Rei</li>
                </ul>
            </div>
        </div>
    </div>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        
        document.addEventListener('DOMContentLoaded', async () => {
            const firebaseConfig = {
              apiKey: "AIzaSyDkF5F_4wL1tE-BK6J6UnZInENW5rOOA3I",
              authDomain: "dominio-acb39.firebaseapp.com",
              projectId: "dominio-acb39",
              storageBucket: "dominio-acb39.firebasestorage.app",
              messagingSenderId: "287882033315",
              appId: "1:287882033315:web:58ba0964bc17c8e008a716",
              measurementId: "G-018FBT2E4V"
            };
            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);
            const auth = getAuth(app);
            
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Authentication failed:", error);
                document.body.innerHTML = `<div class="text-center text-red-500 p-8">Erro de Autenticação.</div>`;
                return;
            }

            const appId = typeof __app_id !== 'undefined' ? __app_id : 'ars-goetia-default';
            const gamesCollectionPath = `/artifacts/${appId}/public/data/ars_goetia_games`;
            
            // DATA (Completo)
            const demons = [ {Nome:"Bael", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Riqueza"}, {Nome:"Paimon", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Conhecimento"}, {Nome:"Beleth", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Riqueza"}, {Nome:"Purson", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Conhecimento"}, {Nome:"Asmoday", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Guerra"}, {Nome:"Vine", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Guerra"}, {Nome:"Balam", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Conhecimento"}, {Nome:"Zagan", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Riqueza"}, {Nome:"Belial", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Riqueza"}, {Nome:"Vassago", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Conhecimento"}, {Nome:"Ipos", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Conhecimento"}, {Nome:"Stolas", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Guerra"}, {Nome:"Orobas", Título:"Rei", Hierarquia:"Alta", Metal:"", Afinidade:"Guerra"}, {Nome:"Agares", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Conhecimento"}, {Nome:"Valefor", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"}, {Nome:"Barbatos", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"}, {Nome:"Bathin", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Guerra"}, {Nome:"Saleos", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"}, {Nome:"Berith", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"}, {Nome:"Astaroth", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Conhecimento"}, {Nome:"Vepar", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Guerra"}, {Nome:"Vual", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"}, {Nome:"Murmur", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Conhecimento"}, {Nome:"Gremory", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"}, {Nome:"Haures", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Guerra"}, {Nome:"Amduscias", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Guerra"}, {Nome:"Dantalion", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Riqueza"}, {Nome:"Aim", Título:"Duque", Hierarquia:"Média", Metal:"Cobre", Afinidade:"Guerra"}, {Nome:"Amon", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Riqueza"}, {Nome:"Naberius", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Conhecimento"}, {Nome:"Forneus", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Riqueza"}, {Nome:"Phenex", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Conhecimento"}, {Nome:"Orias", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Conhecimento"}, {Nome:"Andras", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Guerra"}, {Nome:"Andrealphus", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Conhecimento"}, {Nome:"Cimeies", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Guerra"}, {Nome:"Decarabia", Título:"Marquês", Hierarquia:"Baixa", Metal:"Prata", Afinidade:"Guerra"}, {Nome:"Botis", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Riqueza"}, {Nome:"Glasya-Labolas", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Conhecimento"}, {Nome:"Ronove", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Guerra"}, {Nome:"Furfur", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Guerra"}, {Nome:"Halphas", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Guerra"}, {Nome:"Andromalius", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Riqueza"}, {Nome:"Furcas", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Conhecimento"}, {Nome:"Leraje", Título:"Conde", Hierarquia:"Baixa", Metal:"Estanho", Afinidade:"Guerra"}, {Nome:"Foras", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Riqueza"}, {Nome:"Gaap", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Conhecimento"}, {Nome:"Malphas", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Guerra"}, {Nome:"Ose", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Conhecimento"}, {Nome:"Amy", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Riqueza"}, {Nome:"Valac", Título:"Presidente", Hierarquia:"Baixa", Metal:"Mercúrio", Afinidade:"Riqueza"} ];
            const metals = [...Array(4).fill({Nome: "Cobre", Título: "Duque"}), ...Array(6).fill({Nome: "Prata", Título: "Marquês"}), ...Array(4).fill({Nome: "Mercúrio", Título: "Presidente"}), ...Array(5).fill({Nome: "Estanho", Título: "Conde"})];
            const seals = Array(1).fill({Nome: "Selo de Salomão"});
            const allProphecies = [ { id: 'p1', Nome: 'A Aristocracia Perversa', Desc: 'Capture um domínio com ao menos 4 demônios da afinidade Riqueza.', check: (domain) => domain.filter(c => c.Tipo === 'Demonio' && c.Afinidade === 'Riqueza').length >= 4 }, { id: 'p2', Nome: 'O Monólito Vermelho', Desc: 'Capture um Domínio onde TODOS os demônios são da afinidade Guerra, incluindo o rei.', check: (domain) => { const demons = domain.filter(c => c.Tipo === 'Demonio'); return demons.length > 0 && demons.every(d => d.Afinidade === 'Guerra'); } }, { id: 'p3', Nome: 'A Insurreição dos Iguais', Desc: 'Capture um Domínio com 6 cartas ou mais, onde TODOS os demônios (exceto Reis) são da mesma Hierarquia (Baixa ou Média).', check: (domain) => { const demons = domain.filter(c => c.Tipo === 'Demonio' && c.Hierarquia !== 'Alta'); return domain.length >= 6 && (demons.length > 0 && (demons.every(d => d.Hierarquia === 'Baixa') || demons.every(d => d.Hierarquia === 'Média')) ); } }, { id: 'p4', Nome: 'A Pirâmide Perfeita', Desc: 'Capture um Domínio que contenha a sequência exata de demônios: Presidente -> Conde -> Marquês.', check: (domain) => { if (domain.length < 3) return false; for (let i = 0; i <= domain.length - 3; i++) { const c1 = domain[i]; const c2 = domain[i+1]; const c3 = domain[i+2]; if (c1.Tipo === 'Demonio' && c1.Título === 'Presidente' && c2.Tipo === 'Demonio' && c2.Título === 'Conde' && c3.Tipo === 'Demonio' && c3.Título === 'Marquês') return true; } return false; } }, { id: 'p5', Nome: 'O Tesouro Profano', Desc: 'Capture um Domínio onde mais da metade das cartas são Metais.', check: (domain) => domain.filter(c => c.Tipo === 'Metal').length > domain.length / 2 }, { id: 'p6', Nome: 'O Mosaico do Caos', Desc: 'Capture um Domínio com 5 ou mais demônios (ignorando o Rei), sem que nenhuma Afinidade apareça mais do que duas vezes.', check: (domain) => { const demons = domain.filter(c => c.Tipo === 'Demonio' && c.Hierarquia !== 'Alta'); const counts = demons.reduce((acc, d) => { acc[d.Afinidade] = (acc[d.Afinidade] || 0) + 1; return acc; }, {}); return demons.length >= 5 && Object.values(counts).every(v => v <= 2); } }, { id: 'p7', Nome: 'A Trindade Completa', Desc: 'Capture um Domínio que contenha EXATAMENTE um demônio de cada Afinidade (ignorando o Rei).', check: (domain) => { const demons = domain.filter(c => c.Tipo === 'Demonio' && c.Hierarquia !== 'Alta'); const affinities = new Set(demons.map(d => d.Afinidade)); return demons.length === 3 && affinities.size === 3; } }, { id: 'p8', Nome: 'O Salto da Fé', Desc: 'Capture um Domínio com um Duque, onde TODOS os outros demônios são de Baixa Hierarquia e tenha ao menos 4 demônios.', check: (domain) => { const demons = domain.filter(c => c.Tipo === 'Demonio' && c.Hierarquia !== 'Alta'); return demons.length >= 4 && demons.some(d => d.Hierarquia === 'Média') && demons.filter(d => d.Hierarquia === 'Baixa').length === (demons.length - 1); } }, { id: 'p9', Nome: 'A Prata Romana', Desc: 'Capture um domínio que tenha ao menos 3 cartas de Prata.', check: (domain) => domain.filter(c => c.Tipo === 'Metal' && c.Nome === 'Prata').length >= 3 }, { id: 'p10', Nome: 'A Liga Infernal', Desc: 'Capture um Domínio que contenha pelo menos um de cada um dos 4 tipos de Metal.', check: (domain) => { const metalTypes = new Set(domain.filter(c => c.Tipo === 'Metal').map(m => m.Nome)); return metalTypes.size === 4; } }, { id: 'p11', Nome: 'A Legião Pura', Desc: 'Capture um Domínio que não contenha NENHUMA carta de Metal.', check: (domain) => domain.filter(c => c.Tipo === 'Metal').length === 0 }, { id: 'p12', Nome: 'O Segredo de Astaroth', Desc: 'Capture um Domínio que contenha o Duque Astaroth e 2 ou mais outros demônios de Conhecimento.', check: (domain) => domain.some(c => c.Nome === 'Astaroth') && domain.filter(c => c.Tipo === 'Demonio' && c.Afinidade === 'Conhecimento').length >= 3 }, { id: 'p13', Nome: 'A Orquestra de Amduscias', Desc: 'Capture um Domínio que contenha o Duque Amduscias e possua pelo menos 3 Títulos de demônios diferentes no total (ignorando o Rei).', check: (domain) => { const demons = domain.filter(c => c.Tipo === 'Demonio' && c.Hierarquia !== 'Alta'); const titles = new Set(demons.map(d => d.Título)); return domain.some(c => c.Nome === 'Amduscias') && titles.size >= 3; } }, { id: 'p14', Nome: 'A Corrupção do Sábio', Desc: 'Cumprida se o Selo de Salomão for utilizado na jogada, seja por você ou pelo seu oponente.', check: () => false, event: 'selo_played' }, { id: 'p15', Nome: 'O Servo de Bael', Desc: 'Cumprida se você ou seu oponente capturar um Domínio com o Rei Bael (a captura não pode ser roubada por um Selo).', check: () => false, event: 'bael_played' }, { id: 'p16', Nome: 'O Grito do Abismo', Desc: 'Cumprida se você for forçado a fazer um Sacrifício.', check: () => false, event: 'sacrifice_made' }, { id: 'p17', Nome: 'A Escala da Loucura', Desc: 'Capture um domínio que tenha uma sequência exata de três demônios da mesma Afinidade.', check: (domain) => { if (domain.length < 3) return false; for (let i = 0; i <= domain.length - 3; i++) { const card1 = domain[i]; const card2 = domain[i+1]; const card3 = domain[i+2]; if (card1.Tipo === 'Demonio' && card2.Tipo === 'Demonio' && card3.Tipo === 'Demonio') { if (card1.Afinidade === card2.Afinidade && card1.Afinidade === card3.Afinidade) return true; } } return false; } }, { id: 'p18', Nome: 'O Mestre dos Marionetes', Desc: 'Capture um Domínio onde a primeira carta jogada foi um Duque.', check: (domain) => domain.length > 0 && domain[0].Título === 'Duque' }, ];

            // GLOBAL VARS
            let localGameState = {};
            let localPlayerId = null;
            let gameId = null;
            let unsubscribe = null;
            let sacrificeSelection = [];
            let sacrificeState = { active: false, stage: null };
            let initialDeckSize = 0; 
            let selectedGameMode = 'competitive';
            let isCpuGame = false;

            // HIERARCHY MAPS
            const titleHierarchy = { 'Presidente': 1, 'Conde': 2, 'Marquês': 3, 'Duque': 4 };
            const metalHierarchy = { 'Mercúrio': 1, 'Estanho': 2, 'Prata': 3, 'Cobre': 4 };

            // UTILITY FUNCTIONS
            function getPlayerName(playerNumber, state) {
                return state[`player${playerNumber}`]?.name || `Jogador ${playerNumber}`;
            }
            
            function getProphecyDetails(id) {
                return allProphecies.find(p => p.id === id);
            }

            function formatCardData(card) {
                if (!card) return { displayText: 'Monte Vazio' };
                let text = card.Nome;
                if (card.Tipo === 'Demonio') {
                    text = `${card.Nome} (${card.Título}, ${card.Afinidade}${card.Metal ? ', ' + card.Metal : ''})`;
                } else if (card.Tipo === 'Metal') {
                    text = `Metal: ${card.Nome}`;
                }
                return { ...card, displayText: text };
            }

            async function updateAndRefreshState(state) {
                if (isCpuGame) {
                    localGameState = state;
                    updateUI();
                } else {
                    await updateFirestore(state);
                }
            }

            async function updateFirestore(newState) {
                if (gameId && !isCpuGame) {
                    try {
                        const gameRef = doc(db, gamesCollectionPath, gameId);
                        await setDoc(gameRef, newState);
                    } catch (e) {
                        console.error("Error writing to Firestore: ", e);
                        addLogToState(localGameState, "ERRO: Não foi possível sincronizar.");
                        updateUI();
                    }
                }
            }

            function addLogToState(state, message, options) {
                if (!state.log) state.log = [];
                state.log.unshift({ text: message, type: options?.type || 'normal' });
                if (state.log.length > 30) state.log.pop();
            }

            function showCustomAlert(message) {
                const alertBox = document.createElement('div');
                alertBox.style.cssText = 'position:fixed; top:20px; left:50%; transform:translateX(-50%); background-color:#f8d7da; color:#721c24; padding:1rem; border:1px solid #f5c6cb; border-radius:0.25rem; z-index:1000;';
                alertBox.textContent = message;
                document.body.appendChild(alertBox);
                setTimeout(() => {
                    alertBox.remove();
                }, 3000);
            }

            function playCpuTurn() {
                const state = localGameState;
                const cpuHand = state.player2.hand;
                const topCard = state.discard_pile.length > 0 ? state.discard_pile[state.discard_pile.length - 1] : null;
            
                // --- LÓGICA DE JOGADA NORMAL ---
                const legalMoves = [];
                cpuHand.forEach((card, index) => {
                    if (isLegalMove(card, topCard)) {
                        legalMoves.push({ card, index });
                    }
                });
            
                if (legalMoves.length > 0) {
                    // A CPU tentará jogar a carta de menor valor para guardar as melhores
                    legalMoves.sort((a, b) => (titleHierarchy[a.card.Título] || 0) - (titleHierarchy[b.card.Título] || 0));
                    return { action: 'play', cardIndex: legalMoves[0].index };
                }
            
                // --- NOVA LÓGICA DE SACRIFÍCIO DA CPU ---
                // Se não há jogadas legais, a CPU deve sacrificar.
            
                // 1. Condição de Aniquilação
                if (cpuHand.length < 3) {
                    return { action: 'aniquilado' };
                }
            
                // 2. Planejar o Sacrifício
                // A CPU identificará as 3 cartas de menor valor na mão.
                const sortedHand = [...cpuHand]
                    .map((card, index) => ({ card, originalIndex: index }))
                    .sort((a, b) => (titleHierarchy[a.card.Título] || 0) - (titleHierarchy[b.card.Título] || 0));
            
                // Ela vai descartar as 2 mais fracas e jogar a 3ª mais fraca.
                const indicesToDiscard = [sortedHand[0].originalIndex, sortedHand[1].originalIndex];
                const indexToPlay = sortedHand[2].originalIndex;
            
                // Retorna uma sequência de ações planejada
                return {
                    action: 'sacrifice_sequence',
                    discardIndices: indicesToDiscard,
                    playIndex: indexToPlay
                };
            }

            // GAME LOGIC FUNCTIONS
            function isLegalMove(cardToPlay, topCard) {
                if (!topCard) {
                    return cardToPlay.Título !== 'Rei' && cardToPlay.Tipo !== 'Lendário';
                }
                if (cardToPlay.Tipo === 'Lendário') return false;
                if (cardToPlay.Título === 'Rei') return true;
                if (cardToPlay.Tipo === 'Demonio' && topCard.Tipo === 'Demonio') {
                    const playTitleRank = titleHierarchy[cardToPlay.Título] || 0;
                    const topTitleRank = titleHierarchy[topCard.Título] || 0;
                    if (playTitleRank > topTitleRank) return true;
                }
                if (cardToPlay.Título && cardToPlay.Título === topCard.Título) return true;
                if (cardToPlay.Tipo === 'Demonio' && topCard.Tipo === 'Metal') {
                    if (cardToPlay.Metal && cardToPlay.Metal === topCard.Nome) return true;
                }
                if (cardToPlay.Tipo === 'Metal' && topCard.Tipo === 'Metal') {
                    const playMetalRank = metalHierarchy[cardToPlay.Nome] || 0;
                    const topMetalRank = metalHierarchy[topCard.Nome] || 0;
                    if (playMetalRank > topMetalRank) return true;
                }
                return false;
            }

            // ===================================================================
            // AQUI COMEÇA A NOVA LÓGICA DO EFEITO DE FOGO
            // ===================================================================
            function updateBackgroundEffect(state) {
                const particlesInstance = tsParticles.domItem(0);
                // Adicionada uma verificação para a existência de emissores
                if (!particlesInstance || !initialDeckSize || !particlesInstance.options.emitters?.length) return;
            
                const options = particlesInstance.options;
                let intensity = 0; // De 0.0 a 1.0
            
                if (state.deck && !state.game_over) {
                    const deckUsedPercentage = 1 - (state.deck.length / initialDeckSize);
                    intensity = deckUsedPercentage;
                }
            
                // Controla a taxa do emissor com base na intensidade
                // O número de partículas emitidas aumenta de 5 para 30
                options.emitters[0].rate.quantity = 5 + (25 * intensity);
            
                // Controla a velocidade das partículas com base na intensidade
                // A velocidade aumenta de um intervalo de {3, 7} para {8, 15}
                options.particles.move.speed.min = 3 + (5 * intensity);
                options.particles.move.speed.max = 7 + (8 * intensity);

                // Controla o tamanho das partículas com base na intensidade
                // O tamanho máximo das partículas aumenta de 30 para 50
                options.particles.size.value.min = 10 + (10 * intensity);
                options.particles.size.value.max = 30 + (20 * intensity);
            
                // A cor muda para um vermelho mais intenso em alta intensidade
                if (intensity > 0.8) {
                    options.particles.color.value = ["#ff0000", "#dc2626", "#b91c1c"]; // Vermelho crítico
                } else if (intensity > 0.5) {
                    options.particles.color.value = ["#ff5900", "#ef4444", "#ff8c00"]; // Laranja/vermelho intenso
                } else {
                    options.particles.color.value = ["#ff5900", "#ff8c00", "#ffb347"]; // Cores de fogo padrão
                }
            
                // Atualiza a instância para aplicar as novas opções
                particlesInstance.refresh();
            }
            // ===================================================================
            // AQUI TERMINA A NOVA LÓGICA DO EFEITO DE FOGO
            // ===================================================================


            function checkEventProphecies(eventName, playerNumber, state) {
                const playerId = `player${playerNumber}`;
                let fulfilled = false;
                (state[playerId].prophecies || []).forEach(p => {
                    const details = getProphecyDetails(p.id);
                    if (!p.completed && details && details.event === eventName) {
                        p.completed = true;
                        fulfilled = true;
                        addLogToState(state, `${getPlayerName(playerNumber, state)} cumpriu a profecia: ${details.Nome}!`);
                    }
                });
                if (fulfilled) checkWinCondition(state);
            }
            
            function findFulfillableDomainProphecies(playerNumber, domain, history, state) {
                const prophecyList = state.gameMode === 'cooperative' ? state.sharedProphecies : state[`player${playerNumber}`].prophecies;
                const uncompleted = (prophecyList || []).filter(p => !p.completed);
                if (uncompleted.length === 0) return [];
                const fulfilled = [];
                for (const p of uncompleted) {
                    const details = getProphecyDetails(p.id);
                    if (details && !details.event && details.check(domain, playerNumber, history)) {
                        fulfilled.push(p.id);
                    }
                }
                return fulfilled;
            }

            function checkWinCondition(state) {
                if (state.game_over) return false;
                let winner = null;
                let reason = '';
                if (state.gameMode === 'cooperative') {
                    const completedCount = (state.sharedProphecies || []).filter(p => p.completed).length;
                    if (completedCount >= 7) {
                        winner = 0;
                        reason = 'Ascensão Cooperativa';
                    }
                } else {
                    const p1SecretScore = (state.player1.prophecies || []).filter(p => p.completed).length;
                    const p1PublicScore = (state.publicProphecies || []).filter(p => p.completedBy === 1).length;
                    const p1Score = p1SecretScore + p1PublicScore;
                    const p2SecretScore = (state.player2.prophecies || []).filter(p => p.completed).length;
                    const p2PublicScore = (state.publicProphecies || []).filter(p => p.completedBy === 2).length;
                    const p2Score = p2SecretScore + p2PublicScore;
                    if (p1Score >= 3) {
                        winner = 1;
                        reason = 'Ascensão';
                    } else if (p2Score >= 3) {
                        winner = 2;
                        reason = 'Ascensão';
                    }
                }
                if (winner !== null) {
                    state.game_over = true;
                    state.winner = winner;
                    state.win_reason = reason;
                    return true;
                }
                return false;
            }

            function endGameUI(winner, reason, gameMode, state) {
                const winnerText = document.getElementById('winner-text');
                const reasonText = document.getElementById('win-reason-text');
                if (gameMode === 'cooperative') {
                    winnerText.textContent = winner === 0 ? "Vitória Cooperativa!" : "Derrota...";
                } else {
                    const winnerName = (winner === 0) ? "Ninguém" : getPlayerName(winner, state);
                    winnerText.textContent = winner === 0 ? "Empate!" : `${winnerName} Venceu!`;
                }
                let reasonMessage = '';
                switch(reason) {
                    case 'Ascensão Cooperativa': reasonMessage = 'Vocês ascenderam juntos ao cumprir 7 profecias!'; break;
                    case 'Ascensão': reasonMessage = 'O Mestre ascendeu ao cumprir três profecias.'; break;
                    case 'Esgotamento': reasonMessage = gameMode === 'cooperative' ? 'O grimório se esgotou antes de cumprirem o ritual.' : 'O grimório se esgotou. A vitória foi decidida por profecias.'; break;
                    case 'Aniquilação': reasonMessage = gameMode === 'cooperative' ? 'Um dos jogadores foi aniquilado.' : 'O oponente não pôde continuar e foi aniquilado.'; break;
                    default: reasonMessage = 'O jogo terminou.';
                }
                reasonText.textContent = reasonMessage;
                document.getElementById('end-game-modal').classList.remove('hidden');
            }

            function updateUI() {
                if (!localGameState || !localGameState.deck || !localPlayerId) return;

                updateBackgroundEffect(localGameState); 

                const currentPlayerNumber = localGameState.current_player;
                const localPlayerNumber = localPlayerId === 'player1' ? 1 : 2;
                const isMyTurn = currentPlayerNumber === localPlayerNumber && !(localGameState.seal_decision?.active) && !(localGameState.prophecy_choice?.active);
                
                const isCoop = localGameState.gameMode === 'cooperative';
                document.getElementById('coop-board-container').classList.toggle('hidden', !isCoop);
                document.getElementById('player1-prophecy-area').classList.toggle('hidden', isCoop);
                document.getElementById('player2-prophecy-area').classList.toggle('hidden', isCoop);

                if (isCoop) {
                    const completedCount = (localGameState.sharedProphecies || []).filter(p => p.completed).length;
                    document.getElementById('coop-prophecy-progress').textContent = `${completedCount} / 7`;
                    const coopPropheciesContainer = document.getElementById('coop-prophecies');
                    coopPropheciesContainer.innerHTML = '';
                    (localGameState.sharedProphecies || []).forEach(p => {
                        const details = getProphecyDetails(p.id);
                        const pElem = document.createElement('div');
                        pElem.className = `coop-prophecy p-2 rounded border ${p.completed ? 'bg-green-900 border-green-500' : 'bg-gray-700 border-gray-500'}`;
                        pElem.innerHTML = `<span class="font-bold">${details.Nome}</span><span class="tooltip">${details.Desc}</span>`;
                        if (p.completed) {
                            pElem.classList.add('prophecy-completed');
                            pElem.style.cursor = 'default';
                        }
                        coopPropheciesContainer.appendChild(pElem);
                    });
                }
                
                const publicProphecyContainer = document.getElementById('public-prophecy-container');
                if (localGameState.gameMode === 'competitive' && localGameState.publicProphecies) {
                    publicProphecyContainer.classList.remove('hidden');
                    const publicPropheciesDiv = document.getElementById('public-prophecies');
                    publicPropheciesDiv.innerHTML = '';
                    (localGameState.publicProphecies || []).forEach(p => {
                        const details = getProphecyDetails(p.id);
                        const pElem = document.createElement('div');
                        pElem.className = 'prophecy-public-item';
                        let completedByText = '';
                        if (p.completedBy) {
                            const winnerName = getPlayerName(p.completedBy, localGameState);
                            completedByText = ` <small class="opacity-80">(Por ${winnerName})</small>`;
                            pElem.classList.add(`prophecy-completed-by-p${p.completedBy}`);
                        }
                        pElem.innerHTML = `<span>${details.Nome}</span>${completedByText}<span class="tooltip">${details.Desc}</span>`;
                        publicPropheciesDiv.appendChild(pElem);
                    });
                } else {
                    publicProphecyContainer.classList.add('hidden');
                }

                const p1Name = localGameState.player1.name;
                const p2Name = localGameState.player2.name;
                document.getElementById('player1-area').querySelector('h2').textContent = `${p1Name} ${localPlayerId === 'player1' ? '(Você)' : ''}`;
                document.getElementById('player2-area').querySelector('h2').textContent = p2Name;
                document.getElementById('turn-indicator').textContent = `Turno ${localGameState.turn_count}`;
                
                let turnText = localGameState.status === 'waiting' ? 'Aguardando oponente...' : '';
                if (localGameState.status === 'active' && !turnText) {
                    const isSealDecisionTime = localGameState.seal_decision?.active;
                    const isProphecyChoiceTime = localGameState.prophecy_choice?.active;
                    
                    if (sacrificeState.active && localPlayerNumber === currentPlayerNumber) {
                        if (sacrificeState.stage === 'discarding') {
                            turnText = `SACRIFÍCIO: Escolha 2 cartas para DESCARTAR (${sacrificeSelection.length}/2)`;
                        } else if (sacrificeState.stage === 'playing') {
                            turnText = "SACRIFÍCIO: Agora, escolha 1 carta para JOGAR.";
                        }
                    } 
                    else if (isSealDecisionTime) {
                        turnText = localGameState.seal_decision.player === localPlayerNumber ? 'Sua decisão: Usar o Selo?' : 'Aguardando decisão do oponente...';
                    } else if (isProphecyChoiceTime) {
                        turnText = 'Momento de Decisão da Profecia...';
                    } else if (isMyTurn) {
                        turnText = "É A SUA VEZ!";
                    } else {
                        const currentTurnPlayerName = getPlayerName(currentPlayerNumber, localGameState);
                        turnText = `Vez de ${currentTurnPlayerName}`;
                    }
                }
                document.getElementById('player-turn').textContent = turnText;

                document.getElementById('player1-area').style.borderColor = currentPlayerNumber === 1 ? '#f59e0b' : 'transparent';
                document.getElementById('player2-area').style.borderColor = currentPlayerNumber === 2 ? '#f59e0b' : 'transparent';
                document.getElementById('deck-count').textContent = localGameState.deck.length;
                const topCard = localGameState.discard_pile.length > 0 ? localGameState.discard_pile[localGameState.discard_pile.length - 1] : null;
                document.getElementById('discard-pile-card').textContent = topCard ? formatCardData(topCard).displayText : 'Domínio Vazio';
                
                const logArea = document.getElementById('log-area');
                logArea.innerHTML = '';
                (localGameState.log || []).forEach(logEntry => {
                    const p = document.createElement('p');
                    p.innerHTML = logEntry.type === 'capture' ? `> <strong>${logEntry.text}</strong>` : `> ${logEntry.text}`;
                    logArea.appendChild(p);
                });

                const domainBoard = document.getElementById('domain-board-cards');
                domainBoard.innerHTML = '';
                if (localGameState.discard_pile && localGameState.discard_pile.length > 0) {
                    localGameState.discard_pile.forEach(card => {
                        const cardElement = document.createElement('div');
                        cardElement.className = 'domain-card-item';
                        cardElement.textContent = formatCardData(card).displayText;
                        domainBoard.appendChild(cardElement);
                    });
                }

                const chatInput = document.getElementById('chat-input');
                const sendChatBtn = document.getElementById('send-chat-btn');
                chatInput.disabled = isCpuGame;
                sendChatBtn.disabled = isCpuGame;
                chatInput.placeholder = isCpuGame ? "Chat desabilitado no modo VS CPU" : "Digite sua mensagem...";

                const chatArea = document.getElementById('chat-area');
                chatArea.innerHTML = '';
                (localGameState.chat || []).forEach(msg => {
                    const msgDiv = document.createElement('div');
                    msgDiv.className = `chat-message ${msg.senderId}`;
                    msgDiv.innerHTML = `<span class="sender">${msg.sender}</span>${msg.text}`;
                    chatArea.appendChild(msgDiv);
                });
                chatArea.scrollTop = chatArea.scrollHeight;

                ['player1', 'player2'].forEach(pid => {
                    const handContainer = document.getElementById(`${pid}-hand`);
                    handContainer.innerHTML = '';
                    const handData = localGameState[pid].hand;
                    if (localPlayerId === pid) {
                        handData.forEach((card, index) => {
                            const btn = document.createElement('button');
                            btn.className = 'card-button';
                            if (sacrificeSelection.includes(index) && isMyTurn) btn.classList.add('sacrificing');
                            btn.textContent = formatCardData(card).displayText;
                            btn.onclick = () => handleCardClick(localPlayerNumber, index);
                            btn.disabled = !isMyTurn;
                            handContainer.appendChild(btn);
                        });
                    } else {
                        // Esconde a mão do oponente, mas mostra placeholders
                        for(let i=0; i < handData.length; i++) {
                            const cardPlaceholder = document.createElement('div');
                            cardPlaceholder.className = 'card-button opponent-card flex items-center justify-center';
                            cardPlaceholder.textContent = `Oculta`;
                            handContainer.appendChild(cardPlaceholder);
                        }
                    }
                    
                    if (!isCoop) {
                        const propheciesContainer = document.getElementById(`${pid}-prophecies`);
                        propheciesContainer.innerHTML = '';
                        (localGameState[pid].prophecies || []).forEach(p => {
                            const details = getProphecyDetails(p.id);
                            if (!details) return;
                            const li = document.createElement('li');
                            if (localPlayerId === pid) {
                                li.textContent = details.Nome;
                                const tooltip = document.createElement('span');
                                tooltip.className = 'tooltip';
                                tooltip.textContent = details.Desc;
                                li.appendChild(tooltip);
                            } else {
                                li.textContent = "Profecia Oculta";
                            }
                            if (p.completed) li.classList.add('prophecy-completed');
                            propheciesContainer.appendChild(li);
                        });
                    }
                    document.getElementById(`${pid}-dominions`).textContent = localGameState[pid].domains_captured;
                });

                const sealModal = document.getElementById('seal-decision-modal');
                const isSealDecisionTime = localGameState.seal_decision?.active;
                const amITheSealDecider = isSealDecisionTime && localGameState.seal_decision.player === localPlayerNumber;
                if (amITheSealDecider) {
                    const iHaveTheSeal = localGameState[localPlayerId].hand.some(c => c.Nome === 'Selo de Salomão');
                    const confirmBtn = document.getElementById('confirm-seal-btn');
                    const declineBtn = document.getElementById('decline-seal-btn');
                    const modalText = document.getElementById('seal-modal-text');
                    if (iHaveTheSeal) {
                        modalText.textContent = 'Você deseja usar o seu Selo de Salomão?';
                        confirmBtn.classList.remove('hidden');
                        declineBtn.textContent = 'Não, Passar';
                    } else {
                        modalText.textContent = 'Você não possui o Selo de Salomão.';
                        confirmBtn.classList.add('hidden');
                        declineBtn.textContent = 'Continuar';
                    }
                    sealModal.classList.remove('hidden');
                } else {
                    sealModal.classList.add('hidden');
                }
                
                const prophecyModal = document.getElementById('prophecy-choice-modal');
                const isProphecyChoiceTime = localGameState.prophecy_choice?.active;
                const amITheProphecyDecider = isProphecyChoiceTime && (isCoop || localGameState.prophecy_choice.player === localPlayerNumber);
                if(amITheProphecyDecider) {
                    const optionsContainer = document.getElementById('prophecy-options');
                    optionsContainer.innerHTML = '';
                    localGameState.prophecy_choice.choices.forEach((prophecyChoice, index) => {
                        const details = getProphecyDetails(prophecyChoice.id);
                        const wrapper = document.createElement('div');
                        const radio = document.createElement('input');
                        radio.type = 'radio';
                        const radioId = `prophecy-radio-${prophecyChoice.id}`;
                        radio.id = radioId;
                        radio.name = 'prophecy-selection';
                        radio.value = JSON.stringify(prophecyChoice); 
                        if (index === 0) radio.checked = true;
                        const label = document.createElement('label');
                        label.htmlFor = radioId;
                        label.className = 'prophecy-choice-label';
                        const typeText = prophecyChoice.type === 'public' ? ' (Pública)' : '';
                        label.innerHTML = `<strong class="text-purple-300">${details.Nome}${typeText}</strong><br><small class="text-gray-400">${details.Desc}</small>`;
                        wrapper.appendChild(radio);
                        wrapper.appendChild(label);
                        optionsContainer.appendChild(wrapper);
                    });
                    
                    if (isCoop) {
                        // ... (lógica cooperativa)
                    } else {
                        document.getElementById('prophecy-modal-title').textContent = "Múltiplas Profecias Cumpridas!";
                        document.getElementById('prophecy-modal-text').textContent = "Escolha qual profecia deseja registrar:";
                        document.getElementById('confirm-prophecy-btn').textContent = 'Confirmar';
                        document.getElementById('prophecy-vote-status').classList.add('hidden');
                    }
                    
                    prophecyModal.classList.remove('hidden');
                } else {
                    prophecyModal.classList.add('hidden');
                }

                const isCpuTurn = isCpuGame && localGameState.current_player === 2 && !localGameState.game_over && !localGameState.seal_decision.active && !localGameState.prophecy_choice.active;
                if (isCpuTurn) {
                    document.getElementById('player1-hand').querySelectorAll('button').forEach(btn => btn.disabled = true);
                    
                    setTimeout(async () => {
                        const cpuHandBeforeMove = [...localGameState.player2.hand]; // Guarda o estado da mão antes da jogada
                        const cpuDecision = playCpuTurn();
                        let newState = JSON.parse(JSON.stringify(localGameState));
                        const cpuPlayerId = 'player2';
                        const cpuPlayerName = getPlayerName(2, newState);
                
                        if (cpuDecision.action === 'play') {
                            await playCard(2, cpuDecision.cardIndex, newState);
                
                        } else if (cpuDecision.action === 'aniquilado') {
                            addLogToState(newState, `CPU não pode fazer um sacrifício e é aniquilada!`);
                            newState.game_over = true;
                            newState.winner = 1; // Jogador 1 vence
                            newState.win_reason = 'Aniquilação';
                            await updateAndRefreshState(newState);
                
                        } else if (cpuDecision.action === 'sacrifice_sequence') {
                            addLogToState(newState, `CPU não tem jogadas e deve fazer um Sacrifício.`);
                            
                            // FASE 1: Descartar 2 cartas
                            const sortedDiscardIndices = cpuDecision.discardIndices.sort((a, b) => b - a);
                            const discardedCards = [];
                            sortedDiscardIndices.forEach(index => {
                                const discarded = newState[cpuPlayerId].hand.splice(index, 1)[0];
                                discardedCards.push(discarded);
                            });
                            newState.removed_from_game.push(...discardedCards);
                            addLogToState(newState, `CPU sacrifica e descarta 2 cartas.`);
                            
                            // Ajusta o índice da carta a ser jogada, pois a mão mudou.
                            const cardToPlayObject = cpuHandBeforeMove[cpuDecision.playIndex];
                            const finalPlayIndex = newState[cpuPlayerId].hand.findIndex(c => c.Nome === cardToPlayObject.Nome);
                
                            if (finalPlayIndex > -1) {
                                // FASE 2: Jogar 1 carta
                                const cardToPlay = newState[cpuPlayerId].hand.splice(finalPlayIndex, 1)[0];
                                newState.discard_pile.push(cardToPlay);
                                newState.play_history.push({ player: 2, card: cardToPlay });
                                addLogToState(newState, `...e joga ${formatCardData(cardToPlay).displayText}.`);
                
                                checkEventProphecies('sacrifice_made', 2, newState);

                                if (newState.gameMode === 'cooperative') {
                                    newState.coop_sacrifice_count = (newState.coop_sacrifice_count || 0) + 1;
                                }
                
                                // FASE 3: Comprar 1 carta
                                if (newState.deck.length > 0) {
                                    newState[cpuPlayerId].hand.push(newState.deck.pop());
                                    addLogToState(newState, `CPU compra uma carta.`);
                                }
                
                                // FINALIZAÇÃO: Passar o turno
                                newState.turn_count++;
                                newState.current_player = 1; // Passa o turno para o jogador 1
                
                                if (checkWinCondition(newState)) {
                                    await updateAndRefreshState(newState);
                                    return;
                                }
                                await updateAndRefreshState(newState);
                            }
                        }
                    }, 1500); // Delay para a jogada da CPU ser visível
                }

                const isCpuSealDecision = isCpuGame && localGameState.seal_decision.active && localGameState.seal_decision.player === 2;
                if (isCpuSealDecision) {
                     setTimeout(async () => {
                        const cpuHand = localGameState.player2.hand;
                        if (!cpuHand.some(c => c.Nome === 'Selo de Salomão')) {
                            await handleDeclineSelo(2);
                            return;
                        }
                        const hypotheticalDomain = [...localGameState.discard_pile, localGameState.discard_pile[localGameState.discard_pile.length - 1]];
                        const canFulfillProphecy = localGameState.player2.prophecies.some(p => !p.completed && getProphecyDetails(p.id).check(hypotheticalDomain, 2, localGameState.play_history)) || 
                                                 localGameState.publicProphecies.some(p => !p.completedBy && getProphecyDetails(p.id).check(hypotheticalDomain, 2, localGameState.play_history));

                        if (canFulfillProphecy) {
                            await handleSelo(2);
                        } else {
                            await handleDeclineSelo(2);
                        }
                    }, 2000);
                }

                 const isCpuProphecyChoice = isCpuGame && localGameState.prophecy_choice.active && localGameState.prophecy_choice.player === 2;
                if (isCpuProphecyChoice) {
                    setTimeout(async () => {
                        const chosenProphecy = localGameState.prophecy_choice.choices[0];
                        let newState = JSON.parse(JSON.stringify(localGameState));
                        const playerNumber = 2;
                        const domainOwner = 2;

                        const details = getProphecyDetails(chosenProphecy.id);
                        if (chosenProphecy.type === 'secret') {
                            const prophecy = newState.player2.prophecies.find(p => p.id === chosenProphecy.id);
                            if (prophecy) prophecy.completed = true;
                        } else {
                            const prophecy = newState.publicProphecies.find(p => p.id === chosenProphecy.id);
                            if (prophecy) prophecy.completedBy = playerNumber;
                        }
                        addLogToState(newState, `CPU cumpriu: ${details.Nome}!`);
                        newState.prophecy_choice = { active: false, player: null, choices: [], domain_owner: null, votes: {player1: null, player2: null} };
                        if (checkWinCondition(newState)) {
                            await updateAndRefreshState(newState);
                            return;
                        }
                        advanceTurn(domainOwner, newState);
                        await updateAndRefreshState(newState);
                    }, 1500);
                }


                if (localGameState.game_over) {
                    endGameUI(localGameState.winner, localGameState.win_reason, localGameState.gameMode, localGameState);
                    if(unsubscribe) unsubscribe();
                }
            }
            
            async function handleCardClick(playerNumber, index) {
                const isMyTurn = localGameState.current_player === playerNumber && !(localGameState.seal_decision?.active) && !(localGameState.prophecy_choice?.active);
                if (localGameState.game_over || !isMyTurn) return;
            
                const playerId = `player${playerNumber}`;
                const playerName = getPlayerName(playerNumber, localGameState);
                const hand = localGameState[playerId].hand;
            
                // --- LÓGICA DO SACRIFÍCIO MULTI-FASE ---
                if (sacrificeState.active) {
                    let newState = JSON.parse(JSON.stringify(localGameState));
            
                    // FASE 1: Escolhendo 2 cartas para DESCARTAR
                    if (sacrificeState.stage === 'discarding') {
                        if (sacrificeSelection.includes(index)) {
                            sacrificeSelection = sacrificeSelection.filter(i => i !== index);
                        } else if (sacrificeSelection.length < 2) {
                            sacrificeSelection.push(index);
                        }
                        updateUI(); // Apenas atualiza a UI para mostrar a seleção
            
                        if (sacrificeSelection.length === 2) {
                            // Processa o descarte
                            const sortedIndices = sacrificeSelection.sort((a, b) => b - a);
                            const discardedCards = [];
                            sortedIndices.forEach(i => {
                                const discarded = newState[playerId].hand.splice(i, 1)[0];
                                discardedCards.push(discarded);
                            });
                            
                            newState.removed_from_game.push(...discardedCards);
                            addLogToState(newState, `${playerName} sacrifica e descarta 2 cartas.`);
                            
                            sacrificeSelection = []; // Limpa a seleção
                            sacrificeState.stage = 'playing'; // Avança para a próxima fase
                            await updateAndRefreshState(newState);
                        }
                    }
                    // FASE 2: Escolhendo 1 carta para JOGAR
                    else if (sacrificeState.stage === 'playing') {
                        const cardToPlay = newState[playerId].hand[index];
            
                        // Valida se a carta jogada é o Selo
                        if (cardToPlay.Nome === 'Selo de Salomão') {
                            showCustomAlert("O Selo de Salomão não pode ser jogado durante um Sacrifício.");
                            return;
                        }
                        
                        // Remove a carta da mão e a joga no domínio
                        newState[playerId].hand.splice(index, 1);
                        newState.discard_pile.push(cardToPlay);
                        newState.play_history.push({ player: playerNumber, card: cardToPlay });
                        addLogToState(newState, `...e joga ${formatCardData(cardToPlay).displayText} para iniciar um novo Domínio.`);
                        
                        checkEventProphecies('sacrifice_made', playerNumber, newState);

                        if (newState.gameMode === 'cooperative') {
                            newState.coop_sacrifice_count = (newState.coop_sacrifice_count || 0) + 1;
                        }
                        
                        // FASE 3: O jogador COMPRA uma carta
                        if (newState.deck.length > 0) {
                            const drawnCard = newState.deck.pop();
                            newState[playerId].hand.push(drawnCard);
                            addLogToState(newState, `${playerName} compra uma carta.`);
                            // Verifica se o baralho acabou aqui também
                            if (newState.deck.length === 0) {
                               addLogToState(newState, "O Grimório se esgotou! O jogo termina.");
                               newState.game_over = true;
                               newState.win_reason = 'Esgotamento';
                               // Adicione a lógica de desempate aqui se necessário...
                            }
                        }
                        
                        // FINALIZAÇÃO: Passa o turno para o oponente
                        sacrificeState = { active: false, stage: null };
                        newState.turn_count++;
                        newState.current_player = playerNumber === 1 ? 2 : 1;
                        
                        if (checkWinCondition(newState)) {
                            await updateAndRefreshState(newState);
                            return;
                        }
                        await updateAndRefreshState(newState);
                    }
                    return;
                }
                
                // --- FLUXO DE JOGADA NORMAL (com gatilho para o sacrifício) ---
                const topCard = localGameState.discard_pile.length > 0 ? localGameState.discard_pile[localGameState.discard_pile.length - 1] : null;
                const hasLegalMoves = hand.some(card => isLegalMove(card, topCard));
            
                if (hasLegalMoves) {
                    const cardToPlay = hand[index];
                    if (isLegalMove(cardToPlay, topCard)) {
                        let newState = JSON.parse(JSON.stringify(localGameState));
                        await playCard(playerNumber, index, newState);
                    } else {
                        showCustomAlert("Jogada ilegal.");
                    }
                } else {
                    // CONDIÇÃO DE ANIQUILAÇÃO (gatilho do sacrifício)
                    if (hand.length < 3) {
                        addLogToState(localGameState, `${playerName} não pode fazer um sacrifício (mão < 3 cartas) e é aniquilado!`);
                        let newState = JSON.parse(JSON.stringify(localGameState));
                        const winner = localGameState.gameMode === 'cooperative' ? -1 : (playerNumber === 1 ? 2 : 1);
                        newState.game_over = true;
                        newState.winner = winner;
                        newState.win_reason = 'Aniquilação';
                        await updateAndRefreshState(newState);
                        return;
                    }
            
                    // Ativa o estado de sacrifício
                    sacrificeState = { active: true, stage: 'discarding' };
                    addLogToState(localGameState, `${getPlayerName(playerNumber, localGameState)} não tem jogadas e deve fazer um Sacrifício.`);
                    updateUI(); 
                }
            }

            async function playCard(playerNumber, index, state) {
                const playerId = `player${playerNumber}`;
                const playerName = getPlayerName(playerNumber, state);
                const cardToPlay = state[playerId].hand.splice(index, 1)[0];
                state.discard_pile.push(cardToPlay);
                state.play_history.push({ player: playerNumber, card: cardToPlay });
                addLogToState(state, `${playerName} joga: ${formatCardData(cardToPlay).displayText}`);
                await handleEndOfTurn(playerNumber, cardToPlay, state);
            }

            async function handleEndOfTurn(playerNumber, playedCard, state) {
                if (playedCard.Título === 'Rei') {
                    const opponentNumber = playerNumber === 1 ? 2 : 1;
                    state.seal_decision = { active: true, player: opponentNumber, king_player: playerNumber };
                    await updateAndRefreshState(state);
                } else {
                    advanceTurn(playerNumber, state);
                    if (!checkWinCondition(state)) {
                        await updateAndRefreshState(state);
                    } else {
                        await updateAndRefreshState(state);
                    }
                }
            }

            function advanceTurn(lastPlayer, state) {
                const opponent = lastPlayer === 1 ? 2 : 1;
                const playerWhoDraws = state.current_player;
                if (state.deck.length > 0) {
                    const drawnCard = state.deck.pop();
                    state[`player${playerWhoDraws}`].hand.push(drawnCard);
                    addLogToState(state, `${getPlayerName(playerWhoDraws, state)} compra uma carta.`);
                    if (state.deck.length === 0) {
                        addLogToState(state, "O Grimório se esgotou! O jogo termina.");
                        state.game_over = true;
                        state.win_reason = 'Esgotamento';
                        if (state.gameMode === 'cooperative') {
                             if ((state.sharedProphecies || []).filter(p => p.completed).length < 7) state.winner = -1;
                        } else {
                            const p1Score = (state.player1.prophecies || []).filter(p => p.completed).length + (state.publicProphecies || []).filter(p => p.completedBy === 1).length;
                            const p2Score = (state.player2.prophecies || []).filter(p => p.completed).length + (state.publicProphecies || []).filter(p => p.completedBy === 2).length;
                            if (p1Score > p2Score) state.winner = 1;
                            else if (p2Score > p1Score) state.winner = 2;
                            else {
                                const p1Kings = state.player1.hand.filter(c => c.Título === 'Rei').length;
                                const p2Kings = state.player2.hand.filter(c => c.Título === 'Rei').length;
                                if (p1Kings > p2Kings) state.winner = 1;
                                else if (p2Kings > p1Kings) state.winner = 2;
                                else state.winner = 0;
                            }
                        }
                        return;
                    }
                }
                state.turn_count++;
                state.current_player = opponent;
                sacrificeSelection = [];
            }
            
            async function processDomainCapture(playerNumber, state) {
                const playerName = getPlayerName(playerNumber, state);
                addLogToState(state, `${playerName} captura um Domínio com ${state.discard_pile.length} cartas!`, { type: 'capture' });
                const capturedDomain = [...state.discard_pile];
                
                let allFulfillable = [];
                // No modo cooperativo, a função já pega a lista correta (sharedProphecies)
                const fulfillableSecretOrShared = findFulfillableDomainProphecies(playerNumber, capturedDomain, state.play_history, state);
                fulfillableSecretOrShared.forEach(id => allFulfillable.push({ id, type: 'secret' })); // 'secret' aqui é um tipo genérico para profecias não-públicas

                if (state.gameMode === 'competitive' && state.publicProphecies) {
                    state.publicProphecies.forEach(p => {
                        if (!p.completedBy) {
                            const details = getProphecyDetails(p.id);
                            if (details && !details.event && details.check(capturedDomain, playerNumber, state.play_history)) {
                                allFulfillable.push({ id: p.id, type: 'public' });
                            }
                        }
                    });
                }

                state.discard_pile = [];
                state.removed_from_game.push(...capturedDomain);
                state[`player${playerNumber}`].domains_captured++;

                if (allFulfillable.length > 1) {
                    state.prophecy_choice = { active: true, player: playerNumber, choices: allFulfillable, domain_owner: playerNumber, votes: { player1: null, player2: null } };
                    addLogToState(state, `Múltiplas profecias cumpridas! Momento de decisão.`);
                    await updateAndRefreshState(state);
                } else if (allFulfillable.length === 1) {
                    const prophecyToComplete = allFulfillable[0];
                    const details = getProphecyDetails(prophecyToComplete.id);

                    if (state.gameMode === 'cooperative') {
                        const prophecy = state.sharedProphecies.find(p => p.id === prophecyToComplete.id);
                        if (prophecy) prophecy.completed = true;
                    } 
                    else if (prophecyToComplete.type === 'secret') {
                        const prophecy = state[`player${playerNumber}`].prophecies.find(p => p.id === prophecyToComplete.id);
                        if(prophecy) prophecy.completed = true;
                    } else { // 'public'
                        const prophecy = state.publicProphecies.find(p => p.id === prophecyToComplete.id);
                        if(prophecy) prophecy.completedBy = playerNumber;
                    }

                    addLogToState(state, `Profecia cumprida: ${details.Nome}!`);
                    if (checkWinCondition(state)) {
                        await updateAndRefreshState(state);
                        return;
                    }
                    advanceTurn(playerNumber, state);
                    await updateAndRefreshState(state);
                } else {
                    advanceTurn(playerNumber, state);
                    await updateAndRefreshState(state);
                }
            }
            
            async function handleSelo(playerNumber) {
                if (localGameState.game_over) return;
                let newState = JSON.parse(JSON.stringify(localGameState));
                const kingPlayerNumber = newState.seal_decision.king_player;
                const playerName = getPlayerName(playerNumber, newState);
                addLogToState(newState, `${playerName} usa o Selo de Salomão!`);
                const seloIndex = newState[`player${playerNumber}`].hand.findIndex(c => c.Nome === 'Selo de Salomão');
                if(seloIndex === -1) return;
                newState[`player${playerNumber}`].hand.splice(seloIndex, 1)[0];
                newState.seal_decision = { active: false, player: null, king_player: null };
                if(newState.gameMode === 'competitive') {
                    checkEventProphecies('selo_played', playerNumber, newState);
                    checkEventProphecies('selo_played', kingPlayerNumber, newState);
                }
                await processDomainCapture(playerNumber, newState);
            }

            async function handleDeclineSelo(decliningPlayerNumber) {
                let newState = JSON.parse(JSON.stringify(localGameState));
                const kingPlayerNumber = newState.seal_decision.king_player;
                const playerName = getPlayerName(decliningPlayerNumber, newState);
                
                const kingCard = newState.discard_pile[newState.discard_pile.length - 1];
                if (kingCard && kingCard.Nome === 'Bael') {
                    addLogToState(newState, `O poder de Bael reverbera!`);
                    checkEventProphecies('bael_played', 1, newState);
                    checkEventProphecies('bael_played', 2, newState);
                }
                addLogToState(newState, `${playerName} decide não usar o Selo.`);
                newState.seal_decision = { active: false, player: null, king_player: null };
                await processDomainCapture(kingPlayerNumber, newState);
            }

            async function sendChatMessage() {
                const chatInput = document.getElementById('chat-input');
                const messageText = chatInput.value.trim();
                if (!messageText) return;
                const senderName = localPlayerId === 'player1' ? localGameState.player1.name : localGameState.player2.name;
                const newMessage = { sender: senderName, senderId: localPlayerId, text: messageText, timestamp: new Date().toISOString() };
                let newState = JSON.parse(JSON.stringify(localGameState));
                if (!newState.chat) newState.chat = [];
                newState.chat.push(newMessage);
                if (newState.chat.length > 50) newState.chat.shift();
                await updateAndRefreshState(newState);
                chatInput.value = '';
                chatInput.focus();
            }

            document.getElementById('create-game-btn').addEventListener('click', async () => {
                const playerName = document.getElementById('player-name-input').value.trim();
                if (!playerName) { showCustomAlert("Por favor, digite seu nome."); return; }
                const newGameId = Math.random().toString(36).substr(2, 4).toUpperCase();
                gameId = newGameId;
                localPlayerId = 'player1';
                isCpuGame = false;
                
                const demonDeck = demons.map(d => ({ ...d, Tipo: 'Demonio' }));
                const metalDeck = metals.map(m => ({ ...m, Tipo: 'Metal' }));
                const sealDeck = seals.map(s => ({ ...s, Tipo: 'Lendário' }));
                const fullDeck = [...demonDeck, ...metalDeck, ...sealDeck];
                
                let newGameState = { deck: [], discard_pile: [], play_history: [], removed_from_game: [], log: [], chat: [], player1: { name: playerName, hand: [], prophecies: [], domains_captured: 0, uid: auth.currentUser?.uid || null }, player2: { name: 'Aguardando...', hand: [], prophecies: [], domains_captured: 0, uid: null }, current_player: 1, turn_count: 1, game_over: false, winner: null, status: 'waiting', win_reason: null, seal_decision: { active: false, player: null, king_player: null }, prophecy_choice: { active: false, player: null, choices: [], domain_owner: null, votes: {player1: null, player2: null} }, gameMode: selectedGameMode };
                
                let shuffledDeck = [...fullDeck].sort(() => Math.random() - 0.5);
                const excludedPublicIds = ['p14', 'p15', 'p16'];
                const publicEligibleProphecies = allProphecies.filter(p => !excludedPublicIds.includes(p.id));
                let shuffledPublic = [...publicEligibleProphecies].sort(() => Math.random() - 0.5);
                const publicPropheciesSelection = shuffledPublic.slice(0, 2);
                const secretPropheciesPool = allProphecies.filter(p => !publicPropheciesSelection.find(pub => pub.id === p.id));
                let shuffledSecret = [...secretPropheciesPool].sort(() => Math.random() - 0.5);

                if (selectedGameMode === 'cooperative') {
                    newGameState.sharedProphecies = allProphecies.sort(() => Math.random() - 0.5).slice(0, 7).map(p => ({id: p.id, completed: false}));
                    newGameState.player1.prophecies = [];
                    newGameState.player2.prophecies = [];
                    newGameState.coop_sacrifice_count = 0;
                } else {
                    newGameState.publicProphecies = publicPropheciesSelection.map(p => ({id: p.id, completedBy: null}));
                    newGameState.player1.prophecies = shuffledSecret.slice(0, 3).map(p => ({id: p.id, completed: false}));
                    newGameState.player2.prophecies = shuffledSecret.slice(3, 6).map(p => ({id: p.id, completed: false}));
                }
                initialDeckSize = shuffledDeck.length; 
                newGameState.deck = shuffledDeck;
                for (let i = 0; i < 7; i++) {
                    if(newGameState.deck.length > 0) newGameState.player1.hand.push(newGameState.deck.pop());
                    if(newGameState.deck.length > 0) newGameState.player2.hand.push(newGameState.deck.pop());
                }
                await setDoc(doc(db, gamesCollectionPath, gameId), newGameState);
                document.getElementById('game-id-display').textContent = gameId;
                document.getElementById('game-id-section').classList.remove('hidden');
                document.getElementById('create-game-btn').disabled = true;
                listenToGameChanges(gameId);
            });

            document.getElementById('join-game-btn').addEventListener('click', async () => {
                const joinId = document.getElementById('join-game-input').value.trim().toUpperCase();
                const playerName = document.getElementById('player-name-input').value.trim();
                if (!joinId || !playerName) { showCustomAlert("Preencha o nome e o ID do jogo."); return; }
                const gameRef = doc(db, gamesCollectionPath, joinId);
                const gameSnap = await getDoc(gameRef);
                if (gameSnap.exists() && !gameSnap.data().player2.uid) {
                    gameId = joinId;
                    localPlayerId = 'player2';
                    let gameData = gameSnap.data();
                    gameData.player2.uid = auth.currentUser?.uid || null;
                    gameData.player2.name = playerName;
                    gameData.status = 'active';
                    addLogToState(gameData, `${playerName} entrou. O jogo começou! É a vez de ${gameData.player1.name}.`);
                    await setDoc(gameRef, gameData);
                    listenToGameChanges(gameId);
                } else {
                    showCustomAlert("Jogo não encontrado ou já está cheio.");
                }
            });
            
            async function handleConfirmProphecyChoice() {
                const selectedRadio = document.querySelector('input[name="prophecy-selection"]:checked');
                if (!selectedRadio) { showCustomAlert("Por favor, selecione uma opção."); return; }
                const chosenProphecy = JSON.parse(selectedRadio.value);
                let newState = JSON.parse(JSON.stringify(localGameState));
                const domainOwner = newState.prophecy_choice.domain_owner;
                const playerName = getPlayerName(domainOwner, newState);

                if (newState.gameMode === 'cooperative') {
                    const details = getProphecyDetails(chosenProphecy.id);
                    const prophecy = newState.sharedProphecies.find(p => p.id === chosenProphecy.id);
                    if (prophecy) {
                        prophecy.completed = true;
                    }
                    addLogToState(newState, `${playerName} registrou a profecia cooperativa: ${details.Nome}!`);
                    newState.prophecy_choice = { active: false, player: null, choices: [], domain_owner: null, votes: {player1: null, player2: null} };
                    
                    if (checkWinCondition(newState)) {
                        await updateAndRefreshState(newState);
                        return;
                    }
                    advanceTurn(domainOwner, newState);
                    await updateAndRefreshState(newState);
                } 
                else { // Modo Competitivo
                    const playerNumber = newState.prophecy_choice.player;
                    const details = getProphecyDetails(chosenProphecy.id);
                    if (chosenProphecy.type === 'secret') {
                        const prophecy = newState[`player${playerNumber}`].prophecies.find(p => p.id === chosenProphecy.id);
                        if (prophecy) prophecy.completed = true;
                    } else { // 'public'
                        const prophecy = newState.publicProphecies.find(p => p.id === chosenProphecy.id);
                        if (prophecy) prophecy.completedBy = playerNumber;
                    }
                    addLogToState(newState, `${playerName} cumpriu: ${details.Nome}!`);
                    newState.prophecy_choice = { active: false, player: null, choices: [], domain_owner: null, votes: {player1: null, player2: null} };

                    if (checkWinCondition(newState)) {
                        await updateAndRefreshState(newState);
                        return;
                    }
                    advanceTurn(domainOwner, newState);
                    await updateAndRefreshState(newState);
                }
            }

            document.getElementById('confirm-prophecy-btn').addEventListener('click', handleConfirmProphecyChoice);

            function listenToGameChanges(id) {
                if (isCpuGame) return;
                if (unsubscribe) unsubscribe();
                unsubscribe = onSnapshot(doc(db, gamesCollectionPath, id), (doc) => {
                    if (doc.exists()) {
                        localGameState = doc.data();
                        if (localGameState.status === 'active') {
                            document.getElementById('lobby').classList.add('hidden');
                            document.getElementById('game-board').classList.remove('hidden');
                        }
                        updateUI();
                    } else {
                        if (localGameState && !localGameState.game_over) {
                            showCustomAlert("O jogo foi encerrado.");
                            setTimeout(() => window.location.reload(), 2000);
                        }
                    }
                });
            }

            document.getElementById('confirm-seal-btn').addEventListener('click', () => { if (localGameState.seal_decision?.active) handleSelo(localGameState.seal_decision.player); });
            document.getElementById('decline-seal-btn').addEventListener('click', () => { if (localGameState.seal_decision?.active) handleDeclineSelo(localGameState.seal_decision.player); });
            document.getElementById('send-chat-btn').addEventListener('click', sendChatMessage);
            document.getElementById('chat-input').addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); sendChatMessage(); } });

            const compBtn = document.getElementById('mode-competitive-btn');
            const coopBtn = document.getElementById('mode-cooperative-btn');
            const cpuBtn = document.getElementById('mode-cpu-btn');
            const onlineOptions = document.getElementById('online-options');
            const cpuOptions = document.getElementById('cpu-options');

            function setActiveModeButton(activeBtn) {
                [compBtn, coopBtn, cpuBtn].forEach(btn => btn.classList.remove('active'));
                activeBtn.classList.add('active');
                if (activeBtn === cpuBtn) {
                    onlineOptions.classList.add('hidden');
                    cpuOptions.classList.remove('hidden');
                } else {
                    onlineOptions.classList.remove('hidden');
                    cpuOptions.classList.add('hidden');
                }
            }

            compBtn.addEventListener('click', () => { selectedGameMode = 'competitive'; setActiveModeButton(compBtn); });
            coopBtn.addEventListener('click', () => { selectedGameMode = 'cooperative'; setActiveModeButton(coopBtn); });
            cpuBtn.addEventListener('click', () => { selectedGameMode = 'competitive'; setActiveModeButton(cpuBtn); });
            
            document.getElementById('start-cpu-game-btn').addEventListener('click', () => {
                const playerName = document.getElementById('player-name-input').value.trim();
                if (!playerName) { showCustomAlert("Por favor, digite seu nome para jogar."); return; }
                document.getElementById('lobby').classList.add('hidden');
                document.getElementById('game-board').classList.remove('hidden');
                startCpuGame(playerName);
            });

            function startCpuGame(playerName) {
                isCpuGame = true;
                localPlayerId = 'player1';
                gameId = 'local_cpu_game';
                
                const demonDeck = demons.map(d => ({ ...d, Tipo: 'Demonio' }));
                const metalDeck = metals.map(m => ({ ...m, Tipo: 'Metal' }));
                const sealDeck = seals.map(s => ({ ...s, Tipo: 'Lendário' }));
                const fullDeck = [...demonDeck, ...metalDeck, ...sealDeck];
                let shuffledDeck = [...fullDeck].sort(() => Math.random() - 0.5);

                const excludedPublicIds = ['p14', 'p15', 'p16'];
                const publicEligibleProphecies = allProphecies.filter(p => !excludedPublicIds.includes(p.id));
                let shuffledPublic = [...publicEligibleProphecies].sort(() => Math.random() - 0.5);
                const publicPropheciesSelection = shuffledPublic.slice(0, 2);
                const secretPropheciesPool = allProphecies.filter(p => !publicPropheciesSelection.find(pub => pub.id === p.id));
                let shuffledSecret = [...secretPropheciesPool].sort(() => Math.random() - 0.5);

                initialDeckSize = shuffledDeck.length; 

                localGameState = { deck: shuffledDeck, discard_pile: [], play_history: [], removed_from_game: [], log: [], chat: [], player1: { name: playerName, hand: [], prophecies: shuffledSecret.slice(0, 3).map(p => ({id: p.id, completed: false})), domains_captured: 0 }, player2: { name: 'CPU', hand: [], prophecies: shuffledSecret.slice(3, 6).map(p => ({id: p.id, completed: false})), domains_captured: 0 }, publicProphecies: publicPropheciesSelection.map(p => ({id: p.id, completedBy: null})), current_player: 1, turn_count: 1, game_over: false, winner: null, status: 'active', win_reason: null, seal_decision: { active: false, player: null, king_player: null }, prophecy_choice: { active: false, player: null, choices: [], domain_owner: null, votes: {player1: null, player2: null} }, gameMode: 'competitive' };

                for (let i = 0; i < 7; i++) {
                    if(localGameState.deck.length > 0) localGameState.player1.hand.push(localGameState.deck.pop());
                    if(localGameState.deck.length > 0) localGameState.player2.hand.push(localGameState.deck.pop());
                }

                addLogToState(localGameState, `O jogo contra o CPU começou! É a sua vez.`);
                updateUI();
            }

            window.addEventListener('beforeunload', () => {
                if (gameId && localPlayerId === 'player1' && !localGameState.game_over && !isCpuGame) {
                    deleteDoc(doc(db, gamesCollectionPath, gameId));
                }
            });
        });
    </script>

<script>
    // ===================================================================
    // AQUI ESTÁ A NOVA CONFIGURAÇÃO DE PARTÍCULAS DE FOGO
    // ===================================================================
    document.addEventListener('DOMContentLoaded', async () => {
        await tsParticles.load("tsparticles", {
            fullScreen: {
                enable: true,
                zIndex: -1
            },
            particles: {
                number: {
                    value: 0 // Partículas são geradas pelo emissor
                },
                color: {
                    value: ["#ff5900", "#ff8c00", "#ffb347"] // Cores iniciais do fogo
                },
                shape: {
                    type: "polygon",
                    options: {
                        sides: 6 // Formato mais irregular para parecer chama
                    }
                },
                opacity: {
                    value: { min: 0.1, max: 0.8 },
                    animation: {
                        enable: true,
                        speed: 0.7,
                        sync: false
                    }
                },
                size: {
                    value: { min: 10, max: 30 },
                    animation: {
                        enable: true,
                        speed: 8,
                        sync: false,
                        startValue: "min",
                        destroy: "max"
                    }
                },
                move: {
                    enable: true,
                    speed: { min: 3, max: 7 }, // Velocidade inicial
                    direction: "top",
                    straight: false,
                    outModes: {
                        default: "destroy" // Partículas somem ao sair da tela
                    },
                },
            },
            // O emissor cria um fluxo contínuo de partículas da base
            emitters: [{
                direction: "top",
                position: {
                    x: 50,
                    y: 100 // Emissor na parte inferior
                },
                rate: {
                    delay: 0,
                    quantity: 5 // Taxa de emissão inicial
                },
                size: {
                    width: 100, // Ocupa toda a largura
                    height: 0
                }
            }]
        });
    });
</script>
</body>
</html>

